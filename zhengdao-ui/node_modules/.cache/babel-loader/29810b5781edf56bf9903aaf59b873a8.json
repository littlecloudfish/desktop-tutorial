{"ast":null,"code":"import _regeneratorRuntime from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { defineComponent, ref, provide, watch, unref, nextTick, onMounted, onBeforeUnmount, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { getEdges, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\n\nvar _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      \"default\": \"first\"\n    }\n  },\n  emits: [ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, \"focusin\", \"focusout\", \"focusout-prevented\", \"release-requested\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var forwardRef = ref();\n    var lastFocusBeforeTrapped;\n    var lastFocusAfterTrapped;\n    useEscapeKeydown(function (event) {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    var focusLayer = {\n      paused: false,\n      pause: function pause() {\n        this.paused = true;\n      },\n      resume: function resume() {\n        this.paused = false;\n      }\n    };\n\n    var onKeydown = function onKeydown(e) {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      var key = e.key,\n          altKey = e.altKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          currentTarget = e.currentTarget,\n          shiftKey = e.shiftKey;\n      var loop = props.loop;\n      var isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      var currentFocusingEl = document.activeElement;\n\n      if (isTabbing && currentFocusingEl) {\n        var container = currentTarget;\n\n        var _getEdges = getEdges(container),\n            _getEdges2 = _slicedToArray(_getEdges, 2),\n            first = _getEdges2[0],\n            last = _getEdges2[1];\n\n        var isTabbable = first && last;\n\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            e.preventDefault();\n            emit(\"focusout-prevented\");\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault();\n            if (loop) tryFocus(first, true);\n            emit(\"focusout-prevented\");\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            e.preventDefault();\n            if (loop) tryFocus(last, true);\n            emit(\"focusout-prevented\");\n          }\n        }\n      }\n    };\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown: onKeydown\n    });\n    watch(function () {\n      return props.focusTrapEl;\n    }, function (focusTrapEl) {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, {\n      immediate: true\n    });\n    watch([forwardRef], function (_ref2, _ref3) {\n      var _ref4 = _slicedToArray(_ref2, 1),\n          forwardRef2 = _ref4[0];\n\n      var _ref5 = _slicedToArray(_ref3, 1),\n          oldForwardRef = _ref5[0];\n\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n\n    var trapOnFocus = function trapOnFocus(e) {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n\n    var releaseOnFocus = function releaseOnFocus(e) {\n      return emit(ON_RELEASE_FOCUS_EVT, e);\n    };\n\n    var onFocusIn = function onFocusIn(e) {\n      var trapContainer = unref(forwardRef);\n      if (!trapContainer) return;\n      var target = e.target;\n      var isFocusedInTrap = target && trapContainer.contains(target);\n      if (isFocusedInTrap) emit(\"focusin\", e);\n      if (focusLayer.paused) return;\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n\n    var onFocusOut = function onFocusOut(e) {\n      var trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n\n      if (props.trapped) {\n        var relatedTarget = e.relatedTarget;\n\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(function () {\n            if (!focusLayer.paused && props.trapped) {\n              tryFocus(lastFocusAfterTrapped, true);\n            }\n          }, 0);\n        }\n      } else {\n        var target = e.target;\n        var isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap) emit(\"focusout\", e);\n      }\n    };\n\n    function startTrap() {\n      return _startTrap.apply(this, arguments);\n    }\n\n    function _startTrap() {\n      _startTrap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var trapContainer, prevFocusedElement, isPrevFocusContained, focusEvent;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return nextTick();\n\n              case 2:\n                trapContainer = unref(forwardRef);\n\n                if (trapContainer) {\n                  focusableStack.push(focusLayer);\n                  prevFocusedElement = document.activeElement;\n                  lastFocusBeforeTrapped = prevFocusedElement;\n                  isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n\n                  if (!isPrevFocusContained) {\n                    focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);\n                    trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n                    trapContainer.dispatchEvent(focusEvent);\n\n                    if (!focusEvent.defaultPrevented) {\n                      nextTick(function () {\n                        var focusStartEl = props.focusStartEl;\n\n                        if (!isString(focusStartEl)) {\n                          tryFocus(focusStartEl);\n\n                          if (document.activeElement !== focusStartEl) {\n                            focusStartEl = \"first\";\n                          }\n                        }\n\n                        if (focusStartEl === \"first\") {\n                          focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n                        }\n\n                        if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                          tryFocus(trapContainer);\n                        }\n                      });\n                    }\n                  }\n                }\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return _startTrap.apply(this, arguments);\n    }\n\n    function stopTrap() {\n      var trapContainer = unref(forwardRef);\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        var releasedEvent = new Event(FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED_OPTS);\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n\n        if (!releasedEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body, true);\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);\n        focusableStack.remove(focusLayer);\n      }\n    }\n\n    onMounted(function () {\n      if (props.trapped) {\n        startTrap();\n      }\n\n      watch(function () {\n        return props.trapped;\n      }, function (trapped) {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    onBeforeUnmount(function () {\n      if (props.trapped) {\n        stopTrap();\n      }\n    });\n    return {\n      onKeydown: onKeydown\n    };\n  }\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", {\n    handleKeydown: _ctx.onKeydown\n  });\n}\n\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\n\nexport { ElFocusTrap as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","inheritAttrs","props","loop","trapped","focusTrapEl","focusStartEl","type","Object","String","emits","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","setup","emit","forwardRef","ref","useEscapeKeydown","event","focusLayer","paused","pause","resume","onKeydown","e","key","altKey","ctrlKey","metaKey","currentTarget","shiftKey","EVENT_CODE","currentFocusingEl","document","isTabbing","container","getEdges","first","last","isTabbable","preventDefault","tryFocus","includes","provide","FOCUS_TRAP_INJECTION_KEY","focusTrapRef","watch","value","immediate","forwardRef2","oldForwardRef","onFocusIn","onFocusOut","trapOnFocus","releaseOnFocus","unref","trapContainer","target","isFocusedInTrap","lastFocusAfterTrapped","relatedTarget","isNil","setTimeout","startTrap","nextTick","focusableStack","push","prevFocusedElement","lastFocusBeforeTrapped","isPrevFocusContained","focusEvent","Event","FOCUS_AFTER_TRAPPED","FOCUS_AFTER_TRAPPED_OPTS","dispatchEvent","defaultPrevented","isString","activeElement","focusFirstDescendant","releasedEvent","FOCUS_AFTER_RELEASED","remove","onMounted","stopTrap","onBeforeUnmount","_renderSlot","handleKeydown","_ctx"],"sources":["../../../../../../packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  obtainAllFocusableElements,\n  tryFocus,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            e.preventDefault()\n            emit('focusout-prevented')\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault()\n            if (loop) tryFocus(first, true)\n            emit('focusout-prevented')\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            e.preventDefault()\n            if (loop) tryFocus(last, true)\n            emit('focusout-prevented')\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        const relatedTarget = (e as FocusEvent)\n          .relatedTarget as HTMLElement | null\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          // Give embedded focus layer time to pause this layer before reclaiming focus\n          // And only reclaim focus if it should currently be trapping\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              tryFocus(lastFocusAfterTrapped, true)\n            }\n          }, 0)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new Event(\n          FOCUS_AFTER_RELEASED,\n          FOCUS_AFTER_TRAPPED_OPTS\n        )\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n\n        if (!releasedEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body, true)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}