{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { ref, getCurrentInstance, watch, nextTick } from 'vue';\nimport { SetOperationEnum, NODE_CHECK, NODE_CHECK_CHANGE } from '../virtual-tree.mjs';\n\nfunction useCheck(props, tree) {\n  var checkedKeys = ref( /* @__PURE__ */new Set());\n  var indeterminateKeys = ref( /* @__PURE__ */new Set());\n\n  var _getCurrentInstance = getCurrentInstance(),\n      emit = _getCurrentInstance.emit;\n\n  watch(function () {\n    return tree.value;\n  }, function () {\n    return nextTick(function () {\n      _setCheckedKeys(props.defaultCheckedKeys);\n    });\n  }, {\n    immediate: true\n  });\n\n  var updateCheckedKeys = function updateCheckedKeys() {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return;\n    }\n\n    var _tree$value = tree.value,\n        levelTreeNodeMap = _tree$value.levelTreeNodeMap,\n        maxLevel = _tree$value.maxLevel;\n    var checkedKeySet = checkedKeys.value;\n    var indeterminateKeySet = /* @__PURE__ */new Set();\n\n    for (var level = maxLevel - 1; level >= 1; --level) {\n      var nodes = levelTreeNodeMap.get(level);\n      if (!nodes) continue;\n      nodes.forEach(function (node) {\n        var children = node.children;\n\n        if (children) {\n          var allChecked = true;\n          var hasChecked = false;\n\n          var _iterator = _createForOfIteratorHelper(children),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var childNode = _step.value;\n              var key = childNode.key;\n\n              if (checkedKeySet.has(key)) {\n                hasChecked = true;\n              } else if (indeterminateKeySet.has(key)) {\n                allChecked = false;\n                hasChecked = true;\n                break;\n              } else {\n                allChecked = false;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          if (allChecked) {\n            checkedKeySet.add(node.key);\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key);\n            checkedKeySet[\"delete\"](node.key);\n          } else {\n            checkedKeySet[\"delete\"](node.key);\n            indeterminateKeySet[\"delete\"](node.key);\n          }\n        }\n      });\n    }\n\n    indeterminateKeys.value = indeterminateKeySet;\n  };\n\n  var isChecked = function isChecked(node) {\n    return checkedKeys.value.has(node.key);\n  };\n\n  var isIndeterminate = function isIndeterminate(node) {\n    return indeterminateKeys.value.has(node.key);\n  };\n\n  var toggleCheckbox = function toggleCheckbox(node, isChecked2) {\n    var nodeClick = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var checkedKeySet = checkedKeys.value;\n\n    var toggle = function toggle(node2, checked) {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);\n      var children = node2.children;\n\n      if (!props.checkStrictly && children) {\n        children.forEach(function (childNode) {\n          if (!childNode.disabled) {\n            toggle(childNode, checked);\n          }\n        });\n      }\n    };\n\n    toggle(node, isChecked2);\n    updateCheckedKeys();\n\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked2);\n    }\n  };\n\n  var afterNodeCheck = function afterNodeCheck(node, checked) {\n    var _getChecked = getChecked(),\n        checkedNodes = _getChecked.checkedNodes,\n        checkedKeys2 = _getChecked.checkedKeys;\n\n    var _getHalfChecked = getHalfChecked(),\n        halfCheckedNodes = _getHalfChecked.halfCheckedNodes,\n        halfCheckedKeys = _getHalfChecked.halfCheckedKeys;\n\n    emit(NODE_CHECK, node.data, {\n      checkedKeys: checkedKeys2,\n      checkedNodes: checkedNodes,\n      halfCheckedKeys: halfCheckedKeys,\n      halfCheckedNodes: halfCheckedNodes\n    });\n    emit(NODE_CHECK_CHANGE, node.data, checked);\n  };\n\n  function getCheckedKeys() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return getChecked(leafOnly).checkedKeys;\n  }\n\n  function getCheckedNodes() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return getChecked(leafOnly).checkedNodes;\n  }\n\n  function getHalfCheckedKeys() {\n    return getHalfChecked().halfCheckedKeys;\n  }\n\n  function getHalfCheckedNodes() {\n    return getHalfChecked().halfCheckedNodes;\n  }\n\n  function getChecked() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var checkedNodes = [];\n    var keys = [];\n\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      checkedKeys.value.forEach(function (key) {\n        var node = treeNodeMap.get(key);\n\n        if (node && (!leafOnly || leafOnly && node.isLeaf)) {\n          keys.push(key);\n          checkedNodes.push(node.data);\n        }\n      });\n    }\n\n    return {\n      checkedKeys: keys,\n      checkedNodes: checkedNodes\n    };\n  }\n\n  function getHalfChecked() {\n    var halfCheckedNodes = [];\n    var halfCheckedKeys = [];\n\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      indeterminateKeys.value.forEach(function (key) {\n        var node = treeNodeMap.get(key);\n\n        if (node) {\n          halfCheckedKeys.push(key);\n          halfCheckedNodes.push(node.data);\n        }\n      });\n    }\n\n    return {\n      halfCheckedNodes: halfCheckedNodes,\n      halfCheckedKeys: halfCheckedKeys\n    };\n  }\n\n  function setCheckedKeys(keys) {\n    checkedKeys.value.clear();\n    indeterminateKeys.value.clear();\n\n    _setCheckedKeys(keys);\n  }\n\n  function setChecked(key, isChecked2) {\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var node = tree.value.treeNodeMap.get(key);\n\n      if (node) {\n        toggleCheckbox(node, isChecked2, false);\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys) {\n    if (tree == null ? void 0 : tree.value) {\n      var treeNodeMap = tree.value.treeNodeMap;\n\n      if (props.showCheckbox && treeNodeMap && keys) {\n        var _iterator2 = _createForOfIteratorHelper(keys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n            var node = treeNodeMap.get(key);\n\n            if (node && !isChecked(node)) {\n              toggleCheckbox(node, true, false);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys: updateCheckedKeys,\n    toggleCheckbox: toggleCheckbox,\n    isChecked: isChecked,\n    isIndeterminate: isIndeterminate,\n    getCheckedKeys: getCheckedKeys,\n    getCheckedNodes: getCheckedNodes,\n    getHalfCheckedKeys: getHalfCheckedKeys,\n    getHalfCheckedNodes: getHalfCheckedNodes,\n    setChecked: setChecked,\n    setCheckedKeys: setCheckedKeys\n  };\n}\n\nexport { useCheck };","map":{"version":3,"mappings":"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","names":["useCheck","props","tree","checkedKeys","ref","Set","indeterminateKeys","getCurrentInstance","emit","watch","value","nextTick","_setCheckedKeys","defaultCheckedKeys","immediate","updateCheckedKeys","showCheckbox","checkStrictly","levelTreeNodeMap","maxLevel","checkedKeySet","indeterminateKeySet","level","nodes","get","forEach","node","children","allChecked","hasChecked","childNode","key","has","add","isChecked","isIndeterminate","toggleCheckbox","isChecked2","nodeClick","toggle","node2","checked","SetOperationEnum","ADD","DELETE","disabled","afterNodeCheck","getChecked","checkedNodes","checkedKeys2","getHalfChecked","halfCheckedNodes","halfCheckedKeys","NODE_CHECK","data","NODE_CHECK_CHANGE","getCheckedKeys","leafOnly","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","keys","treeNodeMap","isLeaf","push","setCheckedKeys","clear","setChecked"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useCheck.ts"],"sourcesContent":["import { getCurrentInstance, nextTick, ref, watch } from 'vue'\nimport {\n  NODE_CHECK,\n  NODE_CHECK_CHANGE,\n  SetOperationEnum,\n} from '../virtual-tree'\nimport type { Ref } from 'vue'\nimport type { Tree, TreeKey, TreeNode, TreeNodeData, TreeProps } from '../types'\n\nexport function useCheck(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const checkedKeys = ref<Set<TreeKey>>(new Set())\n  const indeterminateKeys = ref<Set<TreeKey>>(new Set())\n  const { emit } = getCurrentInstance()!\n\n  watch(\n    () => tree.value,\n    () => {\n      return nextTick(() => {\n        _setCheckedKeys(props.defaultCheckedKeys)\n      })\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return\n    }\n    const { levelTreeNodeMap, maxLevel } = tree.value\n    const checkedKeySet = checkedKeys.value\n    const indeterminateKeySet = new Set<TreeKey>()\n    // It is easier to determine the indeterminate state by\n    // traversing from bottom to top\n    // leaf nodes not have indeterminate status and can be skipped\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level)\n      if (!nodes) continue\n      nodes.forEach((node) => {\n        const children = node.children\n        if (children) {\n          // Whether all child nodes are selected\n          let allChecked = true\n          // Whether a child node is selected\n          let hasChecked = false\n          for (const childNode of children) {\n            const key = childNode.key\n            if (checkedKeySet.has(key)) {\n              hasChecked = true\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false\n              hasChecked = true\n              break\n            } else {\n              allChecked = false\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key)\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key)\n            checkedKeySet.delete(node.key)\n          } else {\n            checkedKeySet.delete(node.key)\n            indeterminateKeySet.delete(node.key)\n          }\n        }\n      })\n    }\n    indeterminateKeys.value = indeterminateKeySet\n  }\n\n  const isChecked = (node: TreeNode) => checkedKeys.value.has(node.key)\n\n  const isIndeterminate = (node: TreeNode) =>\n    indeterminateKeys.value.has(node.key)\n\n  const toggleCheckbox = (\n    node: TreeNode,\n    isChecked: boolean,\n    nodeClick = true\n  ) => {\n    const checkedKeySet = checkedKeys.value\n    const toggle = (node: TreeNode, checked: boolean) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](\n        node.key\n      )\n      const children = node.children\n      if (!props.checkStrictly && children) {\n        children.forEach((childNode) => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked)\n          }\n        })\n      }\n    }\n    toggle(node, isChecked)\n    updateCheckedKeys()\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked)\n    }\n  }\n\n  const afterNodeCheck = (node: TreeNode, checked: boolean) => {\n    const { checkedNodes, checkedKeys } = getChecked()\n    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked()\n    emit(NODE_CHECK, node.data, {\n      checkedKeys,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes,\n    })\n    emit(NODE_CHECK_CHANGE, node.data, checked)\n  }\n\n  // expose\n  function getCheckedKeys(leafOnly = false): TreeKey[] {\n    return getChecked(leafOnly).checkedKeys\n  }\n\n  function getCheckedNodes(leafOnly = false): TreeNodeData[] {\n    return getChecked(leafOnly).checkedNodes\n  }\n\n  function getHalfCheckedKeys(): TreeKey[] {\n    return getHalfChecked().halfCheckedKeys\n  }\n\n  function getHalfCheckedNodes(): TreeNodeData[] {\n    return getHalfChecked().halfCheckedNodes\n  }\n\n  function getChecked(leafOnly = false): {\n    checkedKeys: TreeKey[]\n    checkedNodes: TreeNodeData[]\n  } {\n    const checkedNodes: TreeNodeData[] = []\n    const keys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      checkedKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && (!leafOnly || (leafOnly && node.isLeaf))) {\n          keys.push(key)\n          checkedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes,\n    }\n  }\n\n  function getHalfChecked(): {\n    halfCheckedKeys: TreeKey[]\n    halfCheckedNodes: TreeNodeData[]\n  } {\n    const halfCheckedNodes: TreeNodeData[] = []\n    const halfCheckedKeys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      indeterminateKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node) {\n          halfCheckedKeys.push(key)\n          halfCheckedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys,\n    }\n  }\n\n  function setCheckedKeys(keys: TreeKey[]) {\n    checkedKeys.value.clear()\n    indeterminateKeys.value.clear()\n    _setCheckedKeys(keys)\n  }\n\n  function setChecked(key: TreeKey, isChecked: boolean) {\n    if (tree?.value && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key)\n      if (node) {\n        toggleCheckbox(node, isChecked, false)\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys: TreeKey[]) {\n    if (tree?.value) {\n      const { treeNodeMap } = tree.value\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (const key of keys) {\n          const node = treeNodeMap.get(key)\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false)\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    // expose\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}