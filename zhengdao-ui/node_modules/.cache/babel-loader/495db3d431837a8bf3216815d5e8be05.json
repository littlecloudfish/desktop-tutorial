{"ast":null,"code":"import _objectSpread from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, resolveDynamicComponent, h } from 'vue';\nimport { isNumber, isClient } from '@vueuse/core';\nimport '../../../../utils/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport useWheel from '../hooks/use-wheel.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { isHorizontal, getScrollDir, getRTLOffsetType } from '../utils.mjs';\nimport { virtualizedListProps } from '../props.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, BACKWARD, FORWARD, RTL, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, HORIZONTAL } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { hasOwn, isString } from '@vue/shared';\n\nvar createList = function createList(_ref) {\n  var name = _ref.name,\n      getOffset = _ref.getOffset,\n      getItemSize = _ref.getItemSize,\n      getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initCache = _ref.initCache,\n      clearCache = _ref.clearCache,\n      validateProps = _ref.validateProps;\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n          expose = _ref2.expose;\n      validateProps(props);\n      var instance = getCurrentInstance();\n      var ns = useNamespace(\"vl\");\n      var dynamicSizeCache = ref(initCache(props, instance));\n      var getItemStyleCache = useCache();\n      var windowRef = ref();\n      var innerRef = ref();\n      var scrollbarRef = ref();\n      var states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      var itemsToRender = computed(function () {\n        var total = props.total,\n            cache = props.cache;\n\n        var _unref = unref(states),\n            isScrolling = _unref.isScrolling,\n            scrollDir = _unref.scrollDir,\n            scrollOffset = _unref.scrollOffset;\n\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        var startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        var stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        var cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        var cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalSize = computed(function () {\n        return getEstimatedTotalSize(props, unref(dynamicSizeCache));\n      });\n\n      var _isHorizontal = computed(function () {\n        return isHorizontal(props.layout);\n      });\n\n      var windowStyle = computed(function () {\n        var _ref3;\n\n        return [(_ref3 = {\n          position: \"relative\"\n        }, _defineProperty(_ref3, \"overflow-\".concat(_isHorizontal.value ? \"x\" : \"y\"), \"scroll\"), _defineProperty(_ref3, \"WebkitOverflowScrolling\", \"touch\"), _defineProperty(_ref3, \"willChange\", \"transform\"), _ref3), {\n          direction: props.direction,\n          height: isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, props.style];\n      });\n      var innerStyle = computed(function () {\n        var size = unref(estimatedTotalSize);\n        var horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : \"\".concat(size, \"px\"),\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n        };\n      });\n      var clientSize = computed(function () {\n        return _isHorizontal.value ? props.width : props.height;\n      });\n\n      var _useWheel = useWheel({\n        atStartEdge: computed(function () {\n          return states.value.scrollOffset <= 0;\n        }),\n        atEndEdge: computed(function () {\n          return states.value.scrollOffset >= estimatedTotalSize.value;\n        }),\n        layout: computed(function () {\n          return props.layout;\n        })\n      }, function (offset) {\n        var _a, _b;\n\n        ;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      }),\n          onWheel = _useWheel.onWheel;\n\n      var emitEvents = function emitEvents() {\n        var total = props.total;\n\n        if (total > 0) {\n          var _unref2 = unref(itemsToRender),\n              _unref3 = _slicedToArray(_unref2, 4),\n              cacheStart = _unref3[0],\n              cacheEnd = _unref3[1],\n              visibleStart = _unref3[2],\n              visibleEnd = _unref3[3];\n\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n\n        var _unref4 = unref(states),\n            scrollDir = _unref4.scrollDir,\n            scrollOffset = _unref4.scrollOffset,\n            updateRequested = _unref4.updateRequested;\n\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n\n      var scrollVertically = function scrollVertically(e) {\n        var _e$currentTarget = e.currentTarget,\n            clientHeight = _e$currentTarget.clientHeight,\n            scrollHeight = _e$currentTarget.scrollHeight,\n            scrollTop = _e$currentTarget.scrollTop;\n\n        var _states = unref(states);\n\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n\n        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var scrollHorizontally = function scrollHorizontally(e) {\n        var _e$currentTarget2 = e.currentTarget,\n            clientWidth = _e$currentTarget2.clientWidth,\n            scrollLeft = _e$currentTarget2.scrollLeft,\n            scrollWidth = _e$currentTarget2.scrollWidth;\n\n        var _states = unref(states);\n\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n\n        var direction = props.direction;\n        var scrollOffset = scrollLeft;\n\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var onScroll = function onScroll(e) {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n\n      var onScrollbarScroll = function onScrollbarScroll(distanceToGo, totalSteps) {\n        var offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n\n      var scrollTo = function scrollTo(offset) {\n        offset = Math.max(offset, 0);\n\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n\n        states.value = _objectSpread(_objectSpread({}, unref(states)), {}, {\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var scrollToItem = function scrollToItem(idx) {\n        var alignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AUTO_ALIGNMENT;\n\n        var _unref5 = unref(states),\n            scrollOffset = _unref5.scrollOffset;\n\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n\n      var getItemStyle = function getItemStyle(idx) {\n        var direction = props.direction,\n            itemSize = props.itemSize,\n            layout = props.layout;\n        var itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        var style;\n\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          var offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          var size = getItemSize(props, idx, unref(dynamicSizeCache));\n          var horizontal = unref(_isHorizontal);\n          var isRtl = direction === RTL;\n          var offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : \"\".concat(offsetHorizontal, \"px\"),\n            right: isRtl ? \"\".concat(offsetHorizontal, \"px\") : void 0,\n            top: !horizontal ? \"\".concat(offset, \"px\") : 0,\n            height: !horizontal ? \"\".concat(size, \"px\") : \"100%\",\n            width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n          };\n        }\n\n        return style;\n      };\n\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      var resetScrollTop = function resetScrollTop() {\n        var window = windowRef.value;\n\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n\n      onMounted(function () {\n        if (!isClient) return;\n        var initScrollOffset = props.initScrollOffset;\n        var windowElement = unref(windowRef);\n\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(function () {\n        var direction = props.direction,\n            layout = props.layout;\n\n        var _unref6 = unref(states),\n            scrollOffset = _unref6.scrollOffset,\n            updateRequested = _unref6.updateRequested;\n\n        var windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n\n                default:\n                  {\n                    var clientWidth = windowElement.clientWidth,\n                        scrollWidth = windowElement.scrollWidth;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      var api = {\n        ns: ns,\n        clientSize: clientSize,\n        estimatedTotalSize: estimatedTotalSize,\n        windowStyle: windowStyle,\n        windowRef: windowRef,\n        innerRef: innerRef,\n        innerStyle: innerStyle,\n        itemsToRender: itemsToRender,\n        scrollbarRef: scrollbarRef,\n        states: states,\n        getItemStyle: getItemStyle,\n        onScroll: onScroll,\n        onScrollbarScroll: onScrollbarScroll,\n        onWheel: onWheel,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop\n      };\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop,\n        states: states\n      });\n      return api;\n    },\n    render: function render(ctx) {\n      var _a;\n\n      var $slots = ctx.$slots,\n          className = ctx.className,\n          clientSize = ctx.clientSize,\n          containerElement = ctx.containerElement,\n          data = ctx.data,\n          getItemStyle = ctx.getItemStyle,\n          innerElement = ctx.innerElement,\n          itemsToRender = ctx.itemsToRender,\n          innerStyle = ctx.innerStyle,\n          layout = ctx.layout,\n          total = ctx.total,\n          onScroll = ctx.onScroll,\n          onScrollbarScroll = ctx.onScrollbarScroll,\n          onWheel = ctx.onWheel,\n          states = ctx.states,\n          useIsScrolling = ctx.useIsScrolling,\n          windowStyle = ctx.windowStyle,\n          ns = ctx.ns;\n\n      var _itemsToRender = _slicedToArray(itemsToRender, 2),\n          start = _itemsToRender[0],\n          end = _itemsToRender[1];\n\n      var Container = resolveDynamicComponent(containerElement);\n      var Inner = resolveDynamicComponent(innerElement);\n      var children = [];\n\n      if (total > 0) {\n        for (var i = start; i <= end; i++) {\n          children.push((_a = $slots[\"default\"]) == null ? void 0 : _a.call($slots, {\n            data: data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n\n      var InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        \"default\": function _default() {\n          return children;\n        }\n      } : children)];\n      var scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize: clientSize,\n        layout: layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total: total\n      });\n      var listContainer = h(Container, {\n        \"class\": [ns.e(\"window\"), className],\n        style: windowStyle,\n        onScroll: onScroll,\n        onWheel: onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        \"default\": function _default() {\n          return [InnerNode];\n        }\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        \"class\": [ns.e(\"wrapper\"), states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\n\nexport { createList as default };","map":{"version":3,"mappings":"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","names":["createList","name","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","defineComponent","props","virtualizedListProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","instance","getCurrentInstance","ns","useNamespace","dynamicSizeCache","ref","getItemStyleCache","useCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","isNumber","initScrollOffset","updateRequested","isScrollbarDragging","scrollbarAlwaysOn","itemsToRender","computed","total","cache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","FORWARD","min","estimatedTotalSize","_isHorizontal","isHorizontal","layout","windowStyle","position","value","direction","height","width","style","innerStyle","size","horizontal","pointerEvents","clientSize","useWheel","atStartEdge","atEndEdge","offset","_a","_b","onMouseUp","call","scrollTo","onWheel","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","e","currentTarget","clientHeight","scrollHeight","scrollTop","_states","getScrollDir","nextTick","resetIsScrolling","scrollHorizontally","clientWidth","scrollLeft","scrollWidth","RTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","onScroll","onScrollbarScroll","distanceToGo","totalSteps","scrollToItem","idx","alignment","AUTO_ALIGNMENT","getItemStyle","itemSize","itemStyleCache","hasOwn","String","isRtl","offsetHorizontal","left","right","top","resetScrollTop","window","onMounted","isClient","windowElement","onUpdated","HORIZONTAL","api","render","ctx","$slots","className","containerElement","data","innerElement","useIsScrolling","start","end","Container","resolveDynamicComponent","Inner","children","i","push","key","index","InnerNode","h","isString","scrollbar","Scrollbar","ratio","scrollFrom","listContainer"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-list.ts"],"sourcesContent":["// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { hasOwn, isNumber, isString } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { useCache } from '../hooks/use-cache'\nimport useWheel from '../hooks/use-wheel'\nimport Scrollbar from '../components/scrollbar'\nimport { getRTLOffsetType, getScrollDir, isHorizontal } from '../utils'\nimport { virtualizedListProps } from '../props'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  HORIZONTAL,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\n\nimport type { CSSProperties, Slot, VNode, VNodeChild } from 'vue'\nimport type { Alignment, ListConstructorProps } from '../types'\nimport type { VirtualizedListProps } from '../props'\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps,\n}: ListConstructorProps<VirtualizedListProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n\n      const ns = useNamespace('vl')\n\n      const dynamicSizeCache = ref(initCache(props, instance))\n\n      const getItemStyleCache = useCache()\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const innerRef = ref<HTMLElement>()\n      const scrollbarRef = ref()\n      const states = ref({\n        isScrolling: false,\n        scrollDir: 'forward',\n        scrollOffset: isNumber(props.initScrollOffset)\n          ? props.initScrollOffset\n          : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn,\n      })\n\n      // computed\n      const itemsToRender = computed(() => {\n        const { total, cache } = props\n        const { isScrolling, scrollDir, scrollOffset } = unref(states)\n\n        if (total === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getStartIndexForOffset(\n          props,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n        const stopIndex = getStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollOffset,\n          unref(dynamicSizeCache)\n        )\n\n        const cacheBackward =\n          !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1\n        const cacheForward =\n          !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalSize = computed(() =>\n        getEstimatedTotalSize(props, unref(dynamicSizeCache))\n      )\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout))\n\n      const windowStyle = computed(() => [\n        {\n          position: 'relative',\n          [`overflow-${_isHorizontal.value ? 'x' : 'y'}`]: 'scroll',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style,\n      ])\n\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize)\n        const horizontal = unref(_isHorizontal)\n        return {\n          height: horizontal ? '100%' : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width: horizontal ? `${size}px` : '100%',\n        }\n      })\n\n      const clientSize = computed(() =>\n        _isHorizontal.value ? props.width : props.height\n      )\n\n      // methods\n      const { onWheel } = useWheel(\n        {\n          atStartEdge: computed(() => states.value.scrollOffset <= 0),\n          atEndEdge: computed(\n            () => states.value.scrollOffset >= estimatedTotalSize.value\n          ),\n          layout: computed(() => props.layout),\n        },\n        (offset) => {\n          ;(\n            scrollbarRef.value as any as {\n              onMouseUp: () => void\n            }\n          ).onMouseUp?.()\n          scrollTo(\n            Math.min(\n              states.value.scrollOffset + offset,\n              estimatedTotalSize.value - (clientSize.value as number)\n            )\n          )\n        }\n      )\n\n      const emitEvents = () => {\n        const { total } = props\n\n        if (total! > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] =\n            unref(itemsToRender)\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd)\n        }\n\n        const { scrollDir, scrollOffset, updateRequested } = unref(states)\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested)\n      }\n\n      const scrollVertically = (e: Event) => {\n        const { clientHeight, scrollHeight, scrollTop } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n        if (_states.scrollOffset === scrollTop) {\n          return\n        }\n\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollHorizontally = (e: Event) => {\n        const { clientWidth, scrollLeft, scrollWidth } =\n          e.currentTarget as HTMLElement\n        const _states = unref(states)\n\n        if (_states.scrollOffset === scrollLeft) {\n          return\n        }\n\n        const { direction } = props\n\n        let scrollOffset = scrollLeft\n\n        if (direction === RTL) {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft\n              break\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft\n              break\n            }\n          }\n        }\n\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        )\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const onScroll = (e: Event) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e)\n        emitEvents()\n      }\n\n      const onScrollbarScroll = (distanceToGo: number, totalSteps: number) => {\n        const offset =\n          ((estimatedTotalSize.value - (clientSize.value as number)) /\n            totalSteps) *\n          distanceToGo\n        scrollTo(\n          Math.min(\n            estimatedTotalSize.value - (clientSize.value as number),\n            offset\n          )\n        )\n      }\n\n      const scrollTo = (offset: number) => {\n        offset = Math.max(offset, 0)\n\n        if (offset === unref(states).scrollOffset) {\n          return\n        }\n\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        idx: number,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const { scrollOffset } = unref(states)\n\n        idx = Math.max(0, Math.min(idx, props.total! - 1))\n        scrollTo(\n          getOffset(\n            props,\n            idx,\n            alignment,\n            scrollOffset,\n            unref(dynamicSizeCache)\n          )\n        )\n      }\n\n      const getItemStyle = (idx: number) => {\n        const { direction, itemSize, layout } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && itemSize,\n          clearCache && layout,\n          clearCache && direction\n        )\n\n        let style: CSSProperties\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx]\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache))\n          const size = getItemSize(props, idx, unref(dynamicSizeCache))\n          const horizontal = unref(_isHorizontal)\n\n          const isRtl = direction === RTL\n          const offsetHorizontal = horizontal ? offset : 0\n          itemStyleCache[idx] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : undefined,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : '100%',\n            width: horizontal ? `${size}px` : '100%',\n          }\n        }\n\n        return style\n      }\n\n      // TODO:\n      // perf optimization here, reset isScrolling with debounce.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      const resetScrollTop = () => {\n        const window = windowRef.value\n        if (window) {\n          window.scrollTop = 0\n        }\n      }\n\n      // life cycles\n      onMounted(() => {\n        if (!isClient) return\n        const { initScrollOffset } = props\n        const windowElement = unref(windowRef)\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset\n          } else {\n            windowElement.scrollTop = initScrollOffset\n          }\n        }\n\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction, layout } = props\n        const { scrollOffset, updateRequested } = unref(states)\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n              // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n              // So we need to determine which browser behavior we're dealing with, and mimic it.\n              switch (getRTLOffsetType()) {\n                case 'negative': {\n                  windowElement.scrollLeft = -scrollOffset\n                  break\n                }\n                case 'positive-ascending': {\n                  windowElement.scrollLeft = scrollOffset\n                  break\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement\n                  windowElement.scrollLeft =\n                    scrollWidth - clientWidth - scrollOffset\n                  break\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset\n          }\n        }\n      })\n\n      const api = {\n        ns,\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n      }\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states,\n      })\n\n      return api\n    },\n\n    render(ctx: any) {\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle,\n        ns,\n      } = ctx\n\n      const [start, end] = itemsToRender\n\n      const Container = resolveDynamicComponent(containerElement)\n      const Inner = resolveDynamicComponent(innerElement)\n\n      const children = [] as VNodeChild[]\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push(\n            ($slots.default as Slot)?.({\n              data,\n              key: i,\n              index: i,\n              isScrolling: useIsScrolling ? states.isScrolling : undefined,\n              style: getItemStyle(i),\n            })\n          )\n        }\n      }\n\n      const InnerNode = [\n        h(\n          Inner as VNode,\n          {\n            style: innerStyle,\n            ref: 'innerRef',\n          },\n          !isString(Inner)\n            ? {\n                default: () => children,\n              }\n            : children\n        ),\n      ]\n\n      const scrollbar = h(Scrollbar, {\n        ref: 'scrollbarRef',\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: (clientSize * 100) / this.estimatedTotalSize,\n        scrollFrom:\n          states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n      })\n\n      const listContainer = h(\n        Container as VNode,\n        {\n          class: [ns.e('window'), className],\n          style: windowStyle,\n          onScroll,\n          onWheel,\n          ref: 'windowRef',\n          key: 0,\n        },\n        !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]\n      )\n\n      return h(\n        'div',\n        {\n          key: 0,\n          class: [ns.e('wrapper'), states.scrollbarAlwaysOn ? 'always-on' : ''],\n        },\n        [listContainer, scrollbar]\n      )\n    },\n  })\n}\n\nexport default createList\n"]},"metadata":{},"sourceType":"module"}