{"ast":null,"code":"import _defineProperty from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { defineComponent, ref, computed, watch, nextTick, provide, reactive, onMounted, onUpdated, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, createBlock, resolveDynamicComponent, withCtx, renderSlot, createCommentVNode } from 'vue';\nimport { isNumber, useResizeObserver, useEventListener } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { GAP } from './util.mjs';\nimport Bar from './bar2.mjs';\nimport { scrollbarProps, scrollbarEmits } from './scrollbar.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { addUnit } from '../../../utils/dom/style.mjs';\nimport { isObject } from '@vue/shared';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { scrollbarContextKey } from '../../../tokens/scrollbar.mjs';\nvar __default__ = {\n  name: \"ElScrollbar\"\n};\n\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: scrollbarProps,\n  emits: scrollbarEmits,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n        emit = _ref.emit;\n    var props = __props;\n    var ns = useNamespace(\"scrollbar\");\n    var stopResizeObserver = void 0;\n    var stopResizeListener = void 0;\n    var scrollbar$ = ref();\n    var wrap$ = ref();\n    var resize$ = ref();\n    var sizeWidth = ref(\"0\");\n    var sizeHeight = ref(\"0\");\n    var barRef = ref();\n    var ratioY = ref(1);\n    var ratioX = ref(1);\n    var SCOPE = \"ElScrollbar\";\n    var style = computed(function () {\n      var style2 = {};\n      if (props.height) style2.height = addUnit(props.height);\n      if (props.maxHeight) style2.maxHeight = addUnit(props.maxHeight);\n      return [props.wrapStyle, style2];\n    });\n\n    var handleScroll = function handleScroll() {\n      var _a;\n\n      if (wrap$.value) {\n        (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrap$.value);\n        emit(\"scroll\", {\n          scrollTop: wrap$.value.scrollTop,\n          scrollLeft: wrap$.value.scrollLeft\n        });\n      }\n    };\n\n    function scrollTo(arg1, arg2) {\n      if (isObject(arg1)) {\n        wrap$.value.scrollTo(arg1);\n      } else if (isNumber(arg1) && isNumber(arg2)) {\n        wrap$.value.scrollTo(arg1, arg2);\n      }\n    }\n\n    var setScrollTop = function setScrollTop(value) {\n      if (!isNumber(value)) {\n        debugWarn(SCOPE, \"value must be a number\");\n        return;\n      }\n\n      wrap$.value.scrollTop = value;\n    };\n\n    var setScrollLeft = function setScrollLeft(value) {\n      if (!isNumber(value)) {\n        debugWarn(SCOPE, \"value must be a number\");\n        return;\n      }\n\n      wrap$.value.scrollLeft = value;\n    };\n\n    var update = function update() {\n      if (!wrap$.value) return;\n      var offsetHeight = wrap$.value.offsetHeight - GAP;\n      var offsetWidth = wrap$.value.offsetWidth - GAP;\n      var originalHeight = Math.pow(offsetHeight, 2) / wrap$.value.scrollHeight;\n      var originalWidth = Math.pow(offsetWidth, 2) / wrap$.value.scrollWidth;\n      var height = Math.max(originalHeight, props.minSize);\n      var width = Math.max(originalWidth, props.minSize);\n      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));\n      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));\n      sizeHeight.value = height + GAP < offsetHeight ? \"\".concat(height, \"px\") : \"\";\n      sizeWidth.value = width + GAP < offsetWidth ? \"\".concat(width, \"px\") : \"\";\n    };\n\n    watch(function () {\n      return props.noresize;\n    }, function (noresize) {\n      if (noresize) {\n        stopResizeObserver == null ? void 0 : stopResizeObserver();\n        stopResizeListener == null ? void 0 : stopResizeListener();\n      } else {\n        ;\n\n        var _useResizeObserver = useResizeObserver(resize$, update);\n\n        stopResizeObserver = _useResizeObserver.stop;\n        stopResizeListener = useEventListener(\"resize\", update);\n      }\n    }, {\n      immediate: true\n    });\n    watch(function () {\n      return [props.maxHeight, props.height];\n    }, function () {\n      if (!props[\"native\"]) nextTick(function () {\n        var _a;\n\n        update();\n\n        if (wrap$.value) {\n          (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrap$.value);\n        }\n      });\n    });\n    provide(scrollbarContextKey, reactive({\n      scrollbarElement: scrollbar$,\n      wrapElement: wrap$\n    }));\n    onMounted(function () {\n      if (!props[\"native\"]) nextTick(function () {\n        update();\n      });\n    });\n    onUpdated(function () {\n      return update();\n    });\n    expose({\n      wrap$: wrap$,\n      update: update,\n      scrollTo: scrollTo,\n      setScrollTop: setScrollTop,\n      setScrollLeft: setScrollLeft,\n      handleScroll: handleScroll\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"scrollbar$\",\n        ref: scrollbar$,\n        \"class\": normalizeClass(unref(ns).b())\n      }, [createElementVNode(\"div\", {\n        ref_key: \"wrap$\",\n        ref: wrap$,\n        \"class\": normalizeClass([_ctx.wrapClass, unref(ns).e(\"wrap\"), _defineProperty({}, unref(ns).em(\"wrap\", \"hidden-default\"), !_ctx[\"native\"])]),\n        style: normalizeStyle(unref(style)),\n        onScroll: handleScroll\n      }, [(openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {\n        ref_key: \"resize$\",\n        ref: resize$,\n        \"class\": normalizeClass([unref(ns).e(\"view\"), _ctx.viewClass]),\n        style: normalizeStyle(_ctx.viewStyle)\n      }, {\n        \"default\": withCtx(function () {\n          return [renderSlot(_ctx.$slots, \"default\")];\n        }),\n        _: 3\n      }, 8, [\"class\", \"style\"]))], 38), !_ctx[\"native\"] ? (openBlock(), createBlock(Bar, {\n        key: 0,\n        ref_key: \"barRef\",\n        ref: barRef,\n        height: sizeHeight.value,\n        width: sizeWidth.value,\n        always: _ctx.always,\n        \"ratio-x\": ratioX.value,\n        \"ratio-y\": ratioY.value\n      }, null, 8, [\"height\", \"width\", \"always\", \"ratio-x\", \"ratio-y\"])) : createCommentVNode(\"v-if\", true)], 2);\n    };\n  }\n}));\n\nvar Scrollbar = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue\"]]);\n\nexport { Scrollbar as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;IA6DA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA;MACA;MACA;MACA;MACA;IACA,CALA;;IAOA;MACA;;MACA;QAEA;QACAA;UACAC,gCADA;UAEAC;QAFA;MAIA;IAMA,CAfA;;IAgBA;MACA;QAAAC,YACAC,QADA,CACAC,IADA;MAEA,CAFA,MAEA;QACAF;MACA;IAEA;;IACA;MACA;QACAG;QACA;MACA;;MACAH;IAEA,CAPA;;IAQA;MACA;QACAG;QACA;MACA;;MACAH;IAEA,CAPA;;IAQA;MAAA,kBACA;MACA;MAEA;MACA;MACA;MACA;MAEA,SACA,2BACAI,aADA,CADA;MAIAC,eACAC,kBACAC,6BADA,KAEAC,gCAFA,CADA;MAKAC;MACAC;MACAC;IAEA,CAtBA;;IAyBAC;MAAA;IAAA;MACA;QACAC;QACAC;MACA,CAHA,MAGA;QAAA;;QAAA,yBACAC,kCADA;;QACAF,kBADA,sBACAG,IADA;QAEAF;MAEA;IAGA,CAXA,EAWA;MAAAG,SACA;IADA,CAXA;IAcAL;MAAA;IAAA;MACA,sBACAM;QACA;;QACAC;;QACA;UACA;QAEA;MAEA,CARA;IAUA,CAZA;IAaAC,OACA;MAEAC,4BAFA;MAIAC;IAJA,GADA;IAOAC;MACA,sBACAL;QACAC;MACA,CAFA;IAIA,CANA;IAQAK;MAAA;IAAA;IAEAC;MAEAzB,YAFA;MAIAmB,cAJA;MAMAlB,kBANA;MAQAyB,0BARA;MASAC,4BATA;;IAAA","names":["emit","scrollTop","scrollLeft","wrap$","scrollTo","arg1","debugWarn","props","ratioY","originalHeight","offsetHeight","height","ratioX","sizeHeight","sizeWidth","watch","stopResizeObserver","stopResizeListener","useResizeObserver","stop","immediate","nextTick","update","provide","scrollbarElement","wrapElement","onMounted","onUpdated","expose","setScrollTop","setScrollLeft"],"sources":["../../../../../../packages/components/scrollbar/src/scrollbar.vue"],"sourcesContent":["<template>\n  <div ref=\"scrollbar$\" :class=\"ns.b()\">\n    <div\n      ref=\"wrap$\"\n      :class=\"[\n        wrapClass,\n        ns.e('wrap'),\n        { [ns.em('wrap', 'hidden-default')]: !native },\n      ]\"\n      :style=\"style\"\n      @scroll=\"handleScroll\"\n    >\n      <component\n        :is=\"tag\"\n        ref=\"resize$\"\n        :class=\"[ns.e('view'), viewClass]\"\n        :style=\"viewStyle\"\n      >\n        <slot />\n      </component>\n    </div>\n    <template v-if=\"!native\">\n      <bar\n        ref=\"barRef\"\n        :height=\"sizeHeight\"\n        :width=\"sizeWidth\"\n        :always=\"always\"\n        :ratio-x=\"ratioX\"\n        :ratio-y=\"ratioY\"\n      />\n    </template>\n  </div>\n</template>\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onMounted,\n  onUpdated,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { addUnit, debugWarn, isNumber, isObject } from '@element-plus/utils'\nimport { scrollbarContextKey } from '@element-plus/tokens'\nimport { useNamespace } from '@element-plus/hooks'\nimport { GAP } from './util'\nimport Bar from './bar.vue'\nimport { scrollbarEmits, scrollbarProps } from './scrollbar'\nimport type { BarInstance } from './bar'\nimport type { CSSProperties, StyleValue } from 'vue'\n\ndefineOptions({\n  name: 'ElScrollbar',\n})\n\nconst props = defineProps(scrollbarProps)\nconst emit = defineEmits(scrollbarEmits)\n\nconst ns = useNamespace('scrollbar')\n\nlet stopResizeObserver: (() => void) | undefined = undefined\nlet stopResizeListener: (() => void) | undefined = undefined\n\nconst scrollbar$ = ref<HTMLDivElement>()\nconst wrap$ = ref<HTMLDivElement>()\nconst resize$ = ref<HTMLElement>()\n\nconst sizeWidth = ref('0')\nconst sizeHeight = ref('0')\nconst barRef = ref<BarInstance>()\nconst ratioY = ref(1)\nconst ratioX = ref(1)\nconst SCOPE = 'ElScrollbar'\n\nconst style = computed<StyleValue>(() => {\n  const style: CSSProperties = {}\n  if (props.height) style.height = addUnit(props.height)\n  if (props.maxHeight) style.maxHeight = addUnit(props.maxHeight)\n  return [props.wrapStyle, style]\n})\n\nconst handleScroll = () => {\n  if (wrap$.value) {\n    barRef.value?.handleScroll(wrap$.value)\n\n    emit('scroll', {\n      scrollTop: wrap$.value.scrollTop,\n      scrollLeft: wrap$.value.scrollLeft,\n    })\n  }\n}\n\n// TODO: refactor method overrides, due to script setup dts\n// @ts-nocheck\nfunction scrollTo(xCord: number, yCord?: number): void\nfunction scrollTo(options: ScrollToOptions): void\nfunction scrollTo(arg1: unknown, arg2?: number) {\n  if (isObject(arg1)) {\n    wrap$.value!.scrollTo(arg1)\n  } else if (isNumber(arg1) && isNumber(arg2)) {\n    wrap$.value!.scrollTo(arg1, arg2)\n  }\n}\n\nconst setScrollTop = (value: number) => {\n  if (!isNumber(value)) {\n    debugWarn(SCOPE, 'value must be a number')\n    return\n  }\n  wrap$.value!.scrollTop = value\n}\n\nconst setScrollLeft = (value: number) => {\n  if (!isNumber(value)) {\n    debugWarn(SCOPE, 'value must be a number')\n    return\n  }\n  wrap$.value!.scrollLeft = value\n}\n\nconst update = () => {\n  if (!wrap$.value) return\n  const offsetHeight = wrap$.value.offsetHeight - GAP\n  const offsetWidth = wrap$.value.offsetWidth - GAP\n\n  const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight\n  const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth\n  const height = Math.max(originalHeight, props.minSize)\n  const width = Math.max(originalWidth, props.minSize)\n\n  ratioY.value =\n    originalHeight /\n    (offsetHeight - originalHeight) /\n    (height / (offsetHeight - height))\n  ratioX.value =\n    originalWidth /\n    (offsetWidth - originalWidth) /\n    (width / (offsetWidth - width))\n\n  sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : ''\n  sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : ''\n}\n\nwatch(\n  () => props.noresize,\n  (noresize) => {\n    if (noresize) {\n      stopResizeObserver?.()\n      stopResizeListener?.()\n    } else {\n      ;({ stop: stopResizeObserver } = useResizeObserver(resize$, update))\n      stopResizeListener = useEventListener('resize', update)\n    }\n  },\n  { immediate: true }\n)\n\nwatch(\n  () => [props.maxHeight, props.height],\n  () => {\n    if (!props.native)\n      nextTick(() => {\n        update()\n        if (wrap$.value) {\n          barRef.value?.handleScroll(wrap$.value)\n        }\n      })\n  }\n)\n\nprovide(\n  scrollbarContextKey,\n  reactive({\n    scrollbarElement: scrollbar$,\n    wrapElement: wrap$,\n  })\n)\n\nonMounted(() => {\n  if (!props.native)\n    nextTick(() => {\n      update()\n    })\n})\nonUpdated(() => update())\n\ndefineExpose({\n  /** @description scrollbar wrap ref */\n  wrap$,\n  /** @description update scrollbar state manually */\n  update,\n  /** @description scrolls to a particular set of coordinates */\n  scrollTo,\n  /** @description set distance to scroll top */\n  setScrollTop,\n  /** @description set distance to scroll left */\n  setScrollLeft,\n  /** @description handle scroll event */\n  handleScroll,\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}