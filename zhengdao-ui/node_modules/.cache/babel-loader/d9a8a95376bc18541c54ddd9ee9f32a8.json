{"ast":null,"code":"import _objectSpread from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { ref, computed, unref, defineComponent, inject, createVNode } from 'vue';\nimport '../../virtual-list/index.mjs';\nimport '../../../utils/index.mjs';\nimport './components/index.mjs';\nimport { TableV2InjectionKey } from './tokens.mjs';\nimport { tableV2GridProps } from './grid.mjs';\nimport { sum } from './utils.mjs';\nimport { isObject } from '@vue/shared';\nimport { isNumber } from '@vueuse/core';\nimport DynamicSizeGrid from '../../virtual-list/src/components/dynamic-size-grid.mjs';\nimport FixedSizeGrid from '../../virtual-list/src/components/fixed-size-grid.mjs';\nimport TableV2Header from './components/header.mjs';\nvar COMPONENT_NAME = \"ElTableV2Grid\";\n\nvar useTableGrid = function useTableGrid(props) {\n  var headerRef = ref();\n  var bodyRef = ref();\n  var totalHeight = computed(function () {\n    var data = props.data,\n        rowHeight = props.rowHeight,\n        estimatedRowHeight = props.estimatedRowHeight;\n\n    if (estimatedRowHeight) {\n      return;\n    }\n\n    return data.length * rowHeight;\n  });\n  var fixedRowHeight = computed(function () {\n    var fixedData = props.fixedData,\n        rowHeight = props.rowHeight;\n    return ((fixedData == null ? void 0 : fixedData.length) || 0) * rowHeight;\n  });\n  var headerHeight = computed(function () {\n    return sum(props.headerHeight);\n  });\n  var gridHeight = computed(function () {\n    var height = props.height;\n    return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight));\n  });\n  var hasHeader = computed(function () {\n    return unref(headerHeight) + unref(fixedRowHeight) > 0;\n  });\n\n  var itemKey = function itemKey(_ref) {\n    var data = _ref.data,\n        rowIndex = _ref.rowIndex;\n    return data[rowIndex][props.rowKey];\n  };\n\n  function onItemRendered(_ref2) {\n    var rowCacheStart = _ref2.rowCacheStart,\n        rowCacheEnd = _ref2.rowCacheEnd,\n        rowVisibleStart = _ref2.rowVisibleStart,\n        rowVisibleEnd = _ref2.rowVisibleEnd;\n\n    var _a;\n\n    (_a = props.onRowsRendered) == null ? void 0 : _a.call(props, {\n      rowCacheStart: rowCacheStart,\n      rowCacheEnd: rowCacheEnd,\n      rowVisibleStart: rowVisibleStart,\n      rowVisibleEnd: rowVisibleEnd\n    });\n  }\n\n  function resetAfterRowIndex(index, forceUpdate2) {\n    var _a;\n\n    (_a = bodyRef.value) == null ? void 0 : _a.resetAfterRowIndex(index, forceUpdate2);\n  }\n\n  function scrollTo(leftOrOptions, top) {\n    var header$ = unref(headerRef);\n    var body$ = unref(bodyRef);\n    if (!header$ || !body$) return;\n\n    if (isObject(leftOrOptions)) {\n      header$.scrollToLeft(leftOrOptions.scrollLeft);\n      body$.scrollTo(leftOrOptions);\n    } else {\n      header$.scrollToLeft(leftOrOptions);\n      body$.scrollTo({\n        scrollLeft: leftOrOptions,\n        scrollTop: top\n      });\n    }\n  }\n\n  function scrollToTop(scrollTop) {\n    var _a;\n\n    (_a = unref(bodyRef)) == null ? void 0 : _a.scrollTo({\n      scrollTop: scrollTop\n    });\n  }\n\n  function scrollToRow(row, strategy) {\n    var _a;\n\n    (_a = unref(bodyRef)) == null ? void 0 : _a.scrollToItem(row, 1, strategy);\n  }\n\n  function forceUpdate() {\n    var _a, _b;\n\n    (_a = unref(bodyRef)) == null ? void 0 : _a.$forceUpdate();\n    (_b = unref(headerRef)) == null ? void 0 : _b.$forceUpdate();\n  }\n\n  return {\n    bodyRef: bodyRef,\n    forceUpdate: forceUpdate,\n    fixedRowHeight: fixedRowHeight,\n    gridHeight: gridHeight,\n    hasHeader: hasHeader,\n    headerHeight: headerHeight,\n    headerRef: headerRef,\n    totalHeight: totalHeight,\n    itemKey: itemKey,\n    onItemRendered: onItemRendered,\n    resetAfterRowIndex: resetAfterRowIndex,\n    scrollTo: scrollTo,\n    scrollToTop: scrollToTop,\n    scrollToRow: scrollToRow\n  };\n};\n\nvar TableGrid = defineComponent({\n  name: COMPONENT_NAME,\n  props: tableV2GridProps,\n  setup: function setup(props, _ref3) {\n    var slots = _ref3.slots,\n        expose = _ref3.expose;\n\n    var _inject = inject(TableV2InjectionKey),\n        ns = _inject.ns;\n\n    var _useTableGrid = useTableGrid(props),\n        bodyRef = _useTableGrid.bodyRef,\n        fixedRowHeight = _useTableGrid.fixedRowHeight,\n        gridHeight = _useTableGrid.gridHeight,\n        hasHeader = _useTableGrid.hasHeader,\n        headerRef = _useTableGrid.headerRef,\n        headerHeight = _useTableGrid.headerHeight,\n        totalHeight = _useTableGrid.totalHeight,\n        forceUpdate = _useTableGrid.forceUpdate,\n        itemKey = _useTableGrid.itemKey,\n        onItemRendered = _useTableGrid.onItemRendered,\n        resetAfterRowIndex = _useTableGrid.resetAfterRowIndex,\n        scrollTo = _useTableGrid.scrollTo,\n        scrollToTop = _useTableGrid.scrollToTop,\n        scrollToRow = _useTableGrid.scrollToRow;\n\n    expose({\n      forceUpdate: forceUpdate,\n      totalHeight: totalHeight,\n      scrollTo: scrollTo,\n      scrollToTop: scrollToTop,\n      scrollToRow: scrollToRow,\n      resetAfterRowIndex: resetAfterRowIndex\n    });\n\n    var getColumnWidth = function getColumnWidth() {\n      return props.bodyWidth;\n    };\n\n    return function () {\n      var cache = props.cache,\n          columns = props.columns,\n          data = props.data,\n          fixedData = props.fixedData,\n          useIsScrolling = props.useIsScrolling,\n          scrollbarAlwaysOn = props.scrollbarAlwaysOn,\n          scrollbarEndGap = props.scrollbarEndGap,\n          scrollbarStartGap = props.scrollbarStartGap,\n          style = props.style,\n          rowHeight = props.rowHeight,\n          bodyWidth = props.bodyWidth,\n          estimatedRowHeight = props.estimatedRowHeight,\n          headerWidth = props.headerWidth,\n          height = props.height,\n          width = props.width,\n          getRowHeight = props.getRowHeight,\n          onScroll = props.onScroll;\n      var isDynamicRowEnabled = isNumber(estimatedRowHeight);\n      var Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid;\n\n      var _headerHeight = unref(headerHeight);\n\n      return createVNode(\"div\", {\n        \"role\": \"table\",\n        \"class\": [ns.e(\"table\"), props[\"class\"]],\n        \"style\": style\n      }, [createVNode(Grid, {\n        \"ref\": bodyRef,\n        \"data\": data,\n        \"useIsScrolling\": useIsScrolling,\n        \"itemKey\": itemKey,\n        \"columnCache\": 0,\n        \"columnWidth\": isDynamicRowEnabled ? getColumnWidth : bodyWidth,\n        \"totalColumn\": 1,\n        \"totalRow\": data.length,\n        \"rowCache\": cache,\n        \"rowHeight\": isDynamicRowEnabled ? getRowHeight : rowHeight,\n        \"width\": width,\n        \"height\": unref(gridHeight),\n        \"class\": ns.e(\"body\"),\n        \"scrollbarStartGap\": scrollbarStartGap,\n        \"scrollbarEndGap\": scrollbarEndGap,\n        \"scrollbarAlwaysOn\": scrollbarAlwaysOn,\n        \"onScroll\": onScroll,\n        \"onItemRendered\": onItemRendered,\n        \"perfMode\": false\n      }, {\n        \"default\": function _default(params) {\n          var _a;\n\n          var rowData = data[params.rowIndex];\n          return (_a = slots.row) == null ? void 0 : _a.call(slots, _objectSpread(_objectSpread({}, params), {}, {\n            columns: columns,\n            rowData: rowData\n          }));\n        }\n      }), unref(hasHeader) && createVNode(TableV2Header, {\n        \"ref\": headerRef,\n        \"class\": ns.e(\"header-wrapper\"),\n        \"columns\": columns,\n        \"headerData\": data,\n        \"headerHeight\": props.headerHeight,\n        \"fixedHeaderData\": fixedData,\n        \"rowWidth\": headerWidth,\n        \"rowHeight\": rowHeight,\n        \"width\": width,\n        \"height\": Math.min(_headerHeight + unref(fixedRowHeight), height)\n      }, {\n        dynamic: slots.header,\n        fixed: slots.row\n      })]);\n    };\n  }\n});\nexport { TableGrid as default };","map":{"version":3,"mappings":"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","names":["COMPONENT_NAME","useTableGrid","props","headerRef","ref","bodyRef","computed","data","estimatedRowHeight","rowHeight","fixedData","headerHeight","gridHeight","Math","height","max","unref","hasHeader","rowIndex","itemKey","rowVisibleStart","rowCacheStart","_a","rowCacheEnd","rowVisibleEnd","resetAfterRowIndex","header$","body$","leftOrOptions","scrollToLeft","scrollTop","scrollLeft","scrollToTop","_b","scrollToItem","forceUpdate","fixedRowHeight","totalHeight","scrollToRow","slots","expose","TableGrid","ns","inject","onItemRendered","scrollTo","getColumnWidth","cache","columns","scrollbarAlwaysOn","scrollbarEndGap","scrollbarStartGap","style","bodyWidth","headerWidth","getRowHeight","onScroll","_headerHeight","useIsScrolling","isDynamicRowEnabled","width","params","Grid","dynamic","fixed","row"],"sources":["../../../../../../packages/components/table-v2/src/table-grid.tsx"],"sourcesContent":["import { computed, defineComponent, inject, ref, unref } from 'vue'\nimport {\n  DynamicSizeGrid,\n  FixedSizeGrid,\n} from '@element-plus/components/virtual-list'\nimport { isNumber, isObject } from '@element-plus/utils'\nimport { Header } from './components'\nimport { TableV2InjectionKey } from './tokens'\nimport { tableV2GridProps } from './grid'\nimport { sum } from './utils'\n\nimport type { UnwrapRef } from 'vue'\nimport type {\n  DynamicSizeGridInstance,\n  GridDefaultSlotParams,\n  GridItemKeyGetter,\n  GridItemRenderedEvtParams,\n  GridScrollOptions,\n  ResetAfterIndex,\n  Alignment as ScrollStrategy,\n} from '@element-plus/components/virtual-list'\nimport type { TableV2HeaderInstance } from './components'\nimport type { TableV2GridProps } from './grid'\n\nconst COMPONENT_NAME = 'ElTableV2Grid'\n\nconst useTableGrid = (props: TableV2GridProps) => {\n  const headerRef = ref<TableV2HeaderInstance>()\n  const bodyRef = ref<DynamicSizeGridInstance>()\n\n  const totalHeight = computed(() => {\n    const { data, rowHeight, estimatedRowHeight } = props\n\n    if (estimatedRowHeight) {\n      return\n    }\n\n    return data.length * (rowHeight as number)\n  })\n\n  const fixedRowHeight = computed(() => {\n    const { fixedData, rowHeight } = props\n\n    return (fixedData?.length || 0) * (rowHeight as number)\n  })\n\n  const headerHeight = computed(() => sum(props.headerHeight))\n\n  const gridHeight = computed(() => {\n    const { height } = props\n    return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight))\n  })\n\n  const hasHeader = computed(() => {\n    return unref(headerHeight) + unref(fixedRowHeight) > 0\n  })\n\n  const itemKey: GridItemKeyGetter = ({ data, rowIndex }) =>\n    data[rowIndex][props.rowKey]\n\n  function onItemRendered({\n    rowCacheStart,\n    rowCacheEnd,\n    rowVisibleStart,\n    rowVisibleEnd,\n  }: GridItemRenderedEvtParams) {\n    props.onRowsRendered?.({\n      rowCacheStart,\n      rowCacheEnd,\n      rowVisibleStart,\n      rowVisibleEnd,\n    })\n  }\n\n  function resetAfterRowIndex(index: number, forceUpdate: boolean) {\n    bodyRef.value?.resetAfterRowIndex(index, forceUpdate)\n  }\n\n  function scrollTo(x: number, y: number): void\n  function scrollTo(options: GridScrollOptions): void\n  function scrollTo(leftOrOptions: number | GridScrollOptions, top?: number) {\n    const header$ = unref(headerRef)\n    const body$ = unref(bodyRef)\n\n    if (!header$ || !body$) return\n\n    if (isObject(leftOrOptions)) {\n      header$.scrollToLeft(leftOrOptions.scrollLeft)\n      body$.scrollTo(leftOrOptions)\n    } else {\n      header$.scrollToLeft(leftOrOptions)\n      body$.scrollTo({\n        scrollLeft: leftOrOptions,\n        scrollTop: top,\n      })\n    }\n  }\n\n  function scrollToTop(scrollTop: number) {\n    unref(bodyRef)?.scrollTo({\n      scrollTop,\n    })\n  }\n\n  function scrollToRow(row: number, strategy: ScrollStrategy) {\n    unref(bodyRef)?.scrollToItem(row, 1, strategy)\n  }\n\n  function forceUpdate() {\n    unref(bodyRef)?.$forceUpdate()\n    unref(headerRef)?.$forceUpdate()\n  }\n\n  return {\n    bodyRef,\n    forceUpdate,\n    fixedRowHeight,\n    gridHeight,\n    hasHeader,\n    headerHeight,\n    headerRef,\n    totalHeight,\n\n    itemKey,\n    onItemRendered,\n    resetAfterRowIndex,\n    scrollTo,\n    scrollToTop,\n    scrollToRow,\n  }\n}\n\nconst TableGrid = defineComponent({\n  name: COMPONENT_NAME,\n  props: tableV2GridProps,\n  setup(props, { slots, expose }) {\n    const { ns } = inject(TableV2InjectionKey)!\n\n    const {\n      bodyRef,\n      fixedRowHeight,\n      gridHeight,\n      hasHeader,\n      headerRef,\n      headerHeight,\n      totalHeight,\n\n      forceUpdate,\n      itemKey,\n      onItemRendered,\n      resetAfterRowIndex,\n      scrollTo,\n      scrollToTop,\n      scrollToRow,\n    } = useTableGrid(props)\n\n    expose({\n      forceUpdate,\n      /**\n       * @description fetch total height\n       */\n      totalHeight,\n      /**\n       * @description scroll to a position\n       */\n      scrollTo,\n      /**\n       * @description scroll vertically to position y\n       */\n      scrollToTop,\n      /**\n       * @description scroll to a given row\n       * @params row {Number} which row to scroll to\n       * @params strategy {ScrollStrategy} use what strategy to scroll to\n       */\n      scrollToRow,\n      /**\n       * @description reset rendered state after row index\n       */\n      resetAfterRowIndex,\n    })\n\n    const getColumnWidth = () => props.bodyWidth\n\n    return () => {\n      const {\n        cache,\n        columns,\n        data,\n        fixedData,\n        useIsScrolling,\n        scrollbarAlwaysOn,\n        scrollbarEndGap,\n        scrollbarStartGap,\n        style,\n        rowHeight,\n        bodyWidth,\n        estimatedRowHeight,\n        headerWidth,\n        height,\n        width,\n\n        getRowHeight,\n        onScroll,\n      } = props\n\n      const isDynamicRowEnabled = isNumber(estimatedRowHeight)\n      const Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid\n      const _headerHeight = unref(headerHeight)\n\n      return (\n        <div role=\"table\" class={[ns.e('table'), props.class]} style={style}>\n          <Grid\n            ref={bodyRef}\n            // special attrs\n            data={data}\n            useIsScrolling={useIsScrolling}\n            itemKey={itemKey}\n            // column attrs\n            columnCache={0}\n            columnWidth={isDynamicRowEnabled ? getColumnWidth : bodyWidth}\n            totalColumn={1}\n            // row attrs\n            totalRow={data.length}\n            rowCache={cache}\n            rowHeight={isDynamicRowEnabled ? getRowHeight : rowHeight}\n            // DOM attrs\n            width={width}\n            height={unref(gridHeight)}\n            class={ns.e('body')}\n            scrollbarStartGap={scrollbarStartGap}\n            scrollbarEndGap={scrollbarEndGap}\n            scrollbarAlwaysOn={scrollbarAlwaysOn}\n            // handlers\n            onScroll={onScroll}\n            onItemRendered={onItemRendered}\n            perfMode={false}\n          >\n            {{\n              default: (params: GridDefaultSlotParams) => {\n                const rowData = data[params.rowIndex]\n                return slots.row?.({\n                  ...params,\n                  columns,\n                  rowData,\n                })\n              },\n            }}\n          </Grid>\n          {unref(hasHeader) && (\n            <Header\n              ref={headerRef}\n              class={ns.e('header-wrapper')}\n              columns={columns}\n              headerData={data}\n              headerHeight={props.headerHeight}\n              fixedHeaderData={fixedData}\n              rowWidth={headerWidth}\n              rowHeight={rowHeight}\n              width={width}\n              height={Math.min(_headerHeight + unref(fixedRowHeight), height)}\n            >\n              {{\n                dynamic: slots.header,\n                fixed: slots.row,\n              }}\n            </Header>\n          )}\n        </div>\n      )\n    }\n  },\n})\n\nexport default TableGrid\n\nexport type TableGridRowSlotParams = {\n  columns: TableV2GridProps['columns']\n  rowData: any\n} & GridDefaultSlotParams\n\nexport type TableGridInstance = InstanceType<typeof TableGrid> &\n  UnwrapRef<{\n    forceUpdate: () => void\n    /**\n     * @description fetch total height\n     */\n    totalHeight: number\n\n    /**\n     * @description scrollTo a position\n     * @param { number | ScrollToOptions } arg1\n     * @param { number } arg2\n     */\n    scrollTo(leftOrOptions: number | GridScrollOptions, top?: number): void\n\n    /**\n     * @description scroll vertically to position y\n     */\n    scrollToTop(scrollTop: number): void\n    /**\n     * @description scroll to a given row\n     * @params row {Number} which row to scroll to\n     * @params @optional strategy {ScrollStrategy} use what strategy to scroll to\n     */\n    scrollToRow(row: number, strategy: ScrollStrategy): void\n    /**\n     * @description reset rendered state after row index\n     * @param { number } rowIndex\n     * @param { boolean } forceUpdate\n     */\n    resetAfterRowIndex: ResetAfterIndex\n  }>\n"]},"metadata":{},"sourceType":"module"}