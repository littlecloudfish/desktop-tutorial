{"ast":null,"code":"import _toConsumableArray from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { defineComponent, getCurrentInstance, inject, ref, computed, nextTick, watch, onMounted, onUpdated, createVNode } from 'vue';\nimport { NOOP, capitalize } from '@vue/shared';\nimport { useDocumentVisibility, useWindowFocus, useResizeObserver } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport TabBar from './tab-bar2.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { mutable } from '../../../utils/typescript.mjs';\nimport { tabsRootContextKey } from '../../../tokens/tabs.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nvar tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    \"default\": function _default() {\n      return mutable([]);\n    }\n  },\n  currentName: {\n    type: [String, Number],\n    \"default\": \"\"\n  },\n  editable: Boolean,\n  onTabClick: {\n    type: definePropType(Function),\n    \"default\": NOOP\n  },\n  onTabRemove: {\n    type: definePropType(Function),\n    \"default\": NOOP\n  },\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    \"default\": \"\"\n  },\n  stretch: Boolean\n});\nvar COMPONENT_NAME = \"ElTabNav\";\nvar TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  setup: function setup(props, _ref) {\n    var expose = _ref.expose;\n    var vm = getCurrentInstance();\n    var rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, \"<el-tabs><tab-nav /></el-tabs>\");\n    var ns = useNamespace(\"tabs\");\n    var visibility = useDocumentVisibility();\n    var focused = useWindowFocus();\n    var navScroll$ = ref();\n    var nav$ = ref();\n    var el$ = ref();\n    var scrollable = ref(false);\n    var navOffset = ref(0);\n    var isFocus = ref(false);\n    var focusable = ref(true);\n    var sizeName = computed(function () {\n      return [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\";\n    });\n    var navStyle = computed(function () {\n      var dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: \"translate\".concat(dir, \"(-\").concat(navOffset.value, \"px)\")\n      };\n    });\n\n    var scrollPrev = function scrollPrev() {\n      if (!navScroll$.value) return;\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      var newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n\n    var scrollNext = function scrollNext() {\n      if (!navScroll$.value || !nav$.value) return;\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      var newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n\n    var scrollToActiveTab = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var nav, activeTab, navScroll, isHorizontal, activeTabBounding, navScrollBounding, maxOffset, currentOffset, newOffset;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nav = nav$.value;\n\n                if (!(!scrollable.value || !el$.value || !navScroll$.value || !nav)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return nextTick();\n\n              case 5:\n                activeTab = el$.value.querySelector(\".is-active\");\n\n                if (activeTab) {\n                  _context.next = 8;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 8:\n                navScroll = navScroll$.value;\n                isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n                activeTabBounding = activeTab.getBoundingClientRect();\n                navScrollBounding = navScroll.getBoundingClientRect();\n                maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n                currentOffset = navOffset.value;\n                newOffset = currentOffset;\n\n                if (isHorizontal) {\n                  if (activeTabBounding.left < navScrollBounding.left) {\n                    newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n                  }\n\n                  if (activeTabBounding.right > navScrollBounding.right) {\n                    newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n                  }\n                } else {\n                  if (activeTabBounding.top < navScrollBounding.top) {\n                    newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n                  }\n\n                  if (activeTabBounding.bottom > navScrollBounding.bottom) {\n                    newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n                  }\n                }\n\n                newOffset = Math.max(newOffset, 0);\n                navOffset.value = Math.min(newOffset, maxOffset);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function scrollToActiveTab() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    var update = function update() {\n      if (!nav$.value || !navScroll$.value) return;\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n\n      if (containerSize < navSize) {\n        var currentOffset2 = navOffset.value;\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset2;\n        scrollable.value.next = currentOffset2 + containerSize < navSize;\n\n        if (navSize - currentOffset2 < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n\n    var changeTab = function changeTab(e) {\n      var code = e.code;\n      var up = EVENT_CODE.up,\n          down = EVENT_CODE.down,\n          left = EVENT_CODE.left,\n          right = EVENT_CODE.right;\n      if (![up, down, left, right].includes(code)) return;\n      var tabList = Array.from(e.currentTarget.querySelectorAll(\"[role=tab]:not(.is-disabled)\"));\n      var currentIndex = tabList.indexOf(e.target);\n      var nextIndex;\n\n      if (code === left || code === up) {\n        if (currentIndex === 0) {\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        if (currentIndex < tabList.length - 1) {\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n\n      tabList[nextIndex].focus();\n      tabList[nextIndex].click();\n      setFocus();\n    };\n\n    var setFocus = function setFocus() {\n      if (focusable.value) isFocus.value = true;\n    };\n\n    var removeFocus = function removeFocus() {\n      return isFocus.value = false;\n    };\n\n    watch(visibility, function (visibility2) {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(function () {\n          return focusable.value = true;\n        }, 50);\n      }\n    });\n    watch(focused, function (focused2) {\n      if (focused2) {\n        setTimeout(function () {\n          return focusable.value = true;\n        }, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, update);\n    onMounted(function () {\n      return setTimeout(function () {\n        return scrollToActiveTab();\n      }, 0);\n    });\n    onUpdated(function () {\n      return update();\n    });\n    expose({\n      scrollToActiveTab: scrollToActiveTab,\n      removeFocus: removeFocus\n    });\n    watch(function () {\n      return props.panes;\n    }, function () {\n      return vm.update();\n    }, {\n      flush: \"post\"\n    });\n    return function () {\n      var scrollBtn = scrollable.value ? [createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [createVNode(ElIcon, null, {\n        \"default\": function _default() {\n          return [createVNode(ArrowLeft, null, null)];\n        }\n      })]), createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [createVNode(ElIcon, null, {\n        \"default\": function _default() {\n          return [createVNode(ArrowRight, null, null)];\n        }\n      })])] : null;\n      var tabs = props.panes.map(function (pane, index) {\n        var _a, _b, _c, _d;\n\n        var disabled = pane.props.disabled;\n        var tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : \"\".concat(index);\n        var closable = !disabled && (pane.isClosable || props.editable);\n        pane.index = \"\".concat(index);\n        var btnClose = closable ? createVNode(ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": function onClick(ev) {\n            return props.onTabRemove(pane, ev);\n          }\n        }, {\n          \"default\": function _default() {\n            return [createVNode(Close, null, null)];\n          }\n        }) : null;\n        var tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;\n        var tabindex = !disabled && pane.active ? 0 : -1;\n        return createVNode(\"div\", {\n          \"ref\": \"tab-\".concat(tabName),\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": \"tab-\".concat(tabName),\n          \"key\": \"tab-\".concat(tabName),\n          \"aria-controls\": \"pane-\".concat(tabName),\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": function onFocus() {\n            return setFocus();\n          },\n          \"onBlur\": function onBlur() {\n            return removeFocus();\n          },\n          \"onClick\": function onClick(ev) {\n            removeFocus();\n            props.onTabClick(pane, tabName, ev);\n          },\n          \"onKeydown\": function onKeydown(ev) {\n            if (closable && (ev.code === EVENT_CODE[\"delete\"] || ev.code === EVENT_CODE.backspace)) {\n              props.onTabRemove(pane, ev);\n            }\n          }\n        }, [tabLabelContent, btnClose].concat());\n      });\n      return createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab\n      }, [!props.type ? createVNode(TabBar, {\n        \"tabs\": _toConsumableArray(props.panes)\n      }, null) : null, tabs].concat())])]);\n    };\n  }\n});\nexport { TabNav as default, tabNavProps };","map":{"version":3,"mappings":"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","names":["TabBar","tabNavProps","panes","type","definePropType","Array","currentName","Number","editable","Boolean","onTabClick","onTabRemove","String","values","stretch","COMPONENT_NAME","TabNav","name","props","expose","vm","throwError","ns","visibility","useWindowFocus","useDocumentVisibility","focused","navScroll$","nav$","ref","el$","scrollable","navOffset","isFocus","focusable","sizeName","computed","dir","transform","scrollPrev","value","containerSize","newOffset","currentOffset","scrollNext","navSize","capitalize","scrollToActiveTab","nav","activeTab","activeTabBounding","navScrollBounding","includes","rootTabs","tabPosition","maxOffset","isHorizontal","navScroll","right","top","bottom","update","currentOffset2","next","prev","code","up","EVENT_CODE","down","changeTab","tabList","currentIndex","nextIndex","focus","setFocus","watch","useResizeObserver","removeFocus","flush","scrollBtn","setTimeout","onUpdated","_createVNode","disabled","closable","pane","index","btnClose","tabName","ev","is","tabLabelContent","tabs"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.tsx"],"sourcesContent":["// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  inject,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  watch,\n} from 'vue'\nimport { NOOP } from '@vue/shared'\nimport {\n  useDocumentVisibility,\n  useResizeObserver,\n  useWindowFocus,\n} from '@vueuse/core'\nimport {\n  buildProps,\n  capitalize,\n  definePropType,\n  mutable,\n  throwError,\n} from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { tabsRootContextKey } from '@element-plus/tokens'\nimport { useNamespace } from '@element-plus/hooks'\nimport TabBar from './tab-bar.vue'\nimport type { CSSProperties, ExtractPropTypes } from 'vue'\nimport type { TabsPaneContext } from '@element-plus/tokens'\nimport type { TabPanelName } from './tabs'\n\ninterface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: [String, Number],\n    default: '',\n  },\n  editable: Boolean,\n  onTabClick: {\n    type: definePropType<\n      (tab: TabsPaneContext, tabName: TabPanelName, ev: Event) => void\n    >(Function),\n    default: NOOP,\n  },\n  onTabRemove: {\n    type: definePropType<(tab: TabsPaneContext, ev: Event) => void>(Function),\n    default: NOOP,\n  },\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n} as const)\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\n\nconst COMPONENT_NAME = 'ElTabNav'\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n\n  setup(props, { expose }) {\n    const vm = getCurrentInstance()!\n\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`)\n\n    const ns = useNamespace('tabs')\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n\n    const sizeName = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n        ? 'width'\n        : 'height'\n    )\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      await nextTick()\n\n      const activeTab = el$.value.querySelector('.is-active')\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n      const isHorizontal = ['top', 'bottom'].includes(\n        rootTabs.props.tabPosition\n      )\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        const currentOffset = navOffset.value\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (e: KeyboardEvent) => {\n      const code = e.code\n\n      const { up, down, left, right } = EVENT_CODE\n      if (![up, down, left, right].includes(code)) return\n\n      // 左右上下键更换tab\n      const tabList = Array.from(\n        (e.currentTarget as HTMLDivElement).querySelectorAll<HTMLDivElement>(\n          '[role=tab]:not(.is-disabled)'\n        )\n      )\n      const currentIndex = tabList.indexOf(e.target as HTMLDivElement)\n\n      let nextIndex: number\n      if (code === left || code === up) {\n        // left\n        if (currentIndex === 0) {\n          // first\n          nextIndex = tabList.length - 1\n        } else {\n          nextIndex = currentIndex - 1\n        }\n      } else {\n        // right\n        if (currentIndex < tabList.length - 1) {\n          // not last\n          nextIndex = currentIndex + 1\n        } else {\n          nextIndex = 0\n        }\n      }\n      tabList[nextIndex].focus() // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, update)\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n    })\n\n    watch(\n      () => props.panes,\n      () => vm.update(),\n      { flush: 'post' }\n    )\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            <span\n              class={[\n                ns.e('nav-prev'),\n                ns.is('disabled', !scrollable.value.prev),\n              ]}\n              onClick={scrollPrev}\n            >\n              <ElIcon>\n                <ArrowLeft />\n              </ElIcon>\n            </span>,\n            <span\n              class={[\n                ns.e('nav-next'),\n                ns.is('disabled', !scrollable.value.next),\n              ]}\n              onClick={scrollNext}\n            >\n              <ElIcon>\n                <ArrowRight />\n              </ElIcon>\n            </span>,\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const disabled = pane.props.disabled\n        const tabName = pane.props.name ?? pane.index ?? `${index}`\n        const closable = !disabled && (pane.isClosable || props.editable)\n        pane.index = `${index}`\n\n        const btnClose = closable ? (\n          <ElIcon\n            class=\"is-icon-close\"\n            // `onClick` not exist when generate dts\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            onClick={(ev: MouseEvent) => props.onTabRemove(pane, ev)}\n          >\n            <Close />\n          </ElIcon>\n        ) : null\n\n        const tabLabelContent = pane.slots.label?.() || pane.props.label\n        const tabindex = !disabled && pane.active ? 0 : -1\n\n        return (\n          <div\n            ref={`tab-${tabName}`}\n            class={[\n              ns.e('item'),\n              ns.is(rootTabs.props.tabPosition),\n              ns.is('active', pane.active),\n              ns.is('disabled', disabled),\n              ns.is('closable', closable),\n              ns.is('focus', isFocus.value),\n            ]}\n            id={`tab-${tabName}`}\n            key={`tab-${tabName}`}\n            aria-controls={`pane-${tabName}`}\n            role=\"tab\"\n            aria-selected={pane.active}\n            tabindex={tabindex}\n            onFocus={() => setFocus()}\n            onBlur={() => removeFocus()}\n            onClick={(ev: MouseEvent) => {\n              removeFocus()\n              props.onTabClick(pane, tabName, ev)\n            }}\n            onKeydown={(ev: KeyboardEvent) => {\n              if (\n                closable &&\n                (ev.code === EVENT_CODE.delete ||\n                  ev.code === EVENT_CODE.backspace)\n              ) {\n                props.onTabRemove(pane, ev)\n              }\n            }}\n          >\n            {...[tabLabelContent, btnClose]}\n          </div>\n        )\n      })\n\n      return (\n        <div\n          ref={el$}\n          class={[\n            ns.e('nav-wrap'),\n            ns.is('scrollable', !!scrollable.value),\n            ns.is(rootTabs.props.tabPosition),\n          ]}\n        >\n          {scrollBtn}\n          <div class={ns.e('nav-scroll')} ref={navScroll$}>\n            <div\n              class={[\n                ns.e('nav'),\n                ns.is(rootTabs.props.tabPosition),\n                ns.is(\n                  'stretch',\n                  props.stretch &&\n                    ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                ),\n              ]}\n              ref={nav$}\n              style={navStyle.value}\n              role=\"tablist\"\n              onKeydown={changeTab}\n            >\n              {...[\n                !props.type ? <TabBar tabs={[...props.panes]} /> : null,\n                tabs,\n              ]}\n            </div>\n          </div>\n        </div>\n      )\n    }\n  },\n})\n\nexport type TabNavInstance = InstanceType<typeof TabNav>\nexport default TabNav\n"]},"metadata":{},"sourceType":"module"}