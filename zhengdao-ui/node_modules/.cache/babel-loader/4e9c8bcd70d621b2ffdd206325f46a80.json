{"ast":null,"code":"import _objectWithoutProperties from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _excluded = [\"height\"];\nimport \"core-js/modules/es.number.parse-int.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.fixed.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport { inject, ref, computed, unref, nextTick, onMounted, defineComponent, createVNode, mergeProps } from 'vue';\nimport '../../../../utils/index.mjs';\nimport { tableV2RowProps } from '../row.mjs';\nimport { TableV2InjectionKey } from '../tokens.mjs';\nimport { placeholderSign } from '../private.mjs';\nimport { isNumber } from '@vueuse/core';\nimport { isFunction, isArray } from '@vue/shared';\n\nvar useTableRow = function useTableRow(props) {\n  var _inject = inject(TableV2InjectionKey),\n      isScrolling = _inject.isScrolling;\n\n  var measured = ref(false);\n  var rowRef = ref();\n  var measurable = computed(function () {\n    return isNumber(props.estimatedRowHeight) && props.rowIndex >= 0;\n  });\n\n  var doMeasure = function doMeasure() {\n    var isInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var $rowRef = unref(rowRef);\n    if (!$rowRef) return;\n    var columns = props.columns,\n        onRowHeightChange = props.onRowHeightChange,\n        rowKey = props.rowKey,\n        rowIndex = props.rowIndex,\n        style = props.style;\n\n    var _$rowRef$getBoundingC = $rowRef.getBoundingClientRect(),\n        height = _$rowRef$getBoundingC.height;\n\n    measured.value = true;\n    nextTick(function () {\n      if (isInit || height !== Number.parseInt(style.height)) {\n        var firstColumn = columns[0];\n        var isPlaceholder = (firstColumn == null ? void 0 : firstColumn.placeholderSign) === placeholderSign;\n        onRowHeightChange == null ? void 0 : onRowHeightChange({\n          rowKey: rowKey,\n          height: height,\n          rowIndex: rowIndex\n        }, firstColumn && !isPlaceholder && firstColumn.fixed);\n      }\n    });\n  };\n\n  var eventHandlers = computed(function () {\n    var rowData = props.rowData,\n        rowIndex = props.rowIndex,\n        rowKey = props.rowKey,\n        onRowHover = props.onRowHover;\n    var handlers = props.rowEventHandlers || {};\n    var eventHandlers2 = {};\n    Object.entries(handlers).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          eventName = _ref2[0],\n          handler = _ref2[1];\n\n      if (isFunction(handler)) {\n        eventHandlers2[eventName] = function (event) {\n          handler({\n            event: event,\n            rowData: rowData,\n            rowIndex: rowIndex,\n            rowKey: rowKey\n          });\n        };\n      }\n    });\n\n    if (onRowHover) {\n      ;\n      [{\n        name: \"onMouseleave\",\n        hovered: false\n      }, {\n        name: \"onMouseenter\",\n        hovered: true\n      }].forEach(function (_ref3) {\n        var name = _ref3.name,\n            hovered = _ref3.hovered;\n        var existedHandler = eventHandlers2[name];\n\n        eventHandlers2[name] = function (event) {\n          onRowHover({\n            event: event,\n            hovered: hovered,\n            rowData: rowData,\n            rowIndex: rowIndex,\n            rowKey: rowKey\n          });\n          existedHandler == null ? void 0 : existedHandler(event);\n        };\n      });\n    }\n\n    return eventHandlers2;\n  });\n\n  var onExpand = function onExpand(expanded) {\n    var onRowExpand = props.onRowExpand,\n        rowData = props.rowData,\n        rowIndex = props.rowIndex,\n        rowKey = props.rowKey;\n    onRowExpand == null ? void 0 : onRowExpand({\n      expanded: expanded,\n      rowData: rowData,\n      rowIndex: rowIndex,\n      rowKey: rowKey\n    });\n  };\n\n  onMounted(function () {\n    if (unref(measurable)) {\n      doMeasure(true);\n    }\n  });\n  return {\n    isScrolling: isScrolling,\n    measurable: measurable,\n    measured: measured,\n    rowRef: rowRef,\n    eventHandlers: eventHandlers,\n    onExpand: onExpand\n  };\n};\n\nvar COMPONENT_NAME = \"ElTableV2TableRow\";\nvar TableV2Row = defineComponent({\n  name: COMPONENT_NAME,\n  props: tableV2RowProps,\n  setup: function setup(props, _ref4) {\n    var expose = _ref4.expose,\n        slots = _ref4.slots,\n        attrs = _ref4.attrs;\n\n    var _useTableRow = useTableRow(props),\n        eventHandlers = _useTableRow.eventHandlers,\n        isScrolling = _useTableRow.isScrolling,\n        measurable = _useTableRow.measurable,\n        measured = _useTableRow.measured,\n        rowRef = _useTableRow.rowRef,\n        onExpand = _useTableRow.onExpand;\n\n    expose({\n      onExpand: onExpand\n    });\n    return function () {\n      var columns = props.columns,\n          columnsStyles = props.columnsStyles,\n          expandColumnKey = props.expandColumnKey,\n          depth = props.depth,\n          rowData = props.rowData,\n          rowIndex = props.rowIndex,\n          style = props.style;\n      var ColumnCells = columns.map(function (column, columnIndex) {\n        var expandable = isArray(rowData.children) && rowData.children.length > 0 && column.key === expandColumnKey;\n        return slots.cell({\n          column: column,\n          columns: columns,\n          columnIndex: columnIndex,\n          depth: depth,\n          style: columnsStyles[column.key],\n          rowData: rowData,\n          rowIndex: rowIndex,\n          isScrolling: unref(isScrolling),\n          expandIconProps: expandable ? {\n            rowData: rowData,\n            rowIndex: rowIndex,\n            onExpand: onExpand\n          } : void 0\n        });\n      });\n\n      if (slots.row) {\n        ColumnCells = slots.row({\n          cells: ColumnCells.map(function (node) {\n            if (isArray(node) && node.length === 1) {\n              return node[0];\n            }\n\n            return node;\n          }),\n          style: style,\n          columns: columns,\n          depth: depth,\n          rowData: rowData,\n          rowIndex: rowIndex,\n          isScrolling: unref(isScrolling)\n        });\n      }\n\n      if (unref(measurable)) {\n        var _ref5 = style || {},\n            height = _ref5.height,\n            exceptHeightStyle = _objectWithoutProperties(_ref5, _excluded);\n\n        var _measured = unref(measured);\n\n        return createVNode(\"div\", mergeProps({\n          \"ref\": rowRef,\n          \"class\": props[\"class\"],\n          \"style\": _measured ? style : exceptHeightStyle\n        }, attrs, unref(eventHandlers)), [ColumnCells]);\n      }\n\n      return createVNode(\"div\", mergeProps(attrs, {\n        \"ref\": rowRef,\n        \"class\": props[\"class\"],\n        \"style\": style\n      }, unref(eventHandlers)), [ColumnCells]);\n    };\n  }\n});\nexport { TableV2Row as default };","map":{"version":3,"mappings":"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","names":["useTableRow","isScrolling","inject","TableV2InjectionKey","measured","rowRef","ref","computed","isNumber","props","doMeasure","columns","style","onRowHeightChange","rowKey","rowIndex","height","$rowRef","getBoundingClientRect","value","nextTick","firstColumn","placeholderSign","eventHandlers","rowData","onRowHover","eventHandlers2","Object","handlers","rowEventHandlers","event","eventName","isFunction","handler","hovered","name","forEach","existedHandler","onExpand","onRowExpand","unref","onMounted","COMPONENT_NAME","expose","slots","TableV2Row","attrs","measurable","columnsStyles","column","columnIndex","depth","ColumnCells","expandable","node","undefined","cells","isArray","_measured","_createVNode"],"sources":["../../../../../../../packages/components/table-v2/src/components/row.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  inject,\n  nextTick,\n  onMounted,\n  ref,\n  unref,\n} from 'vue'\nimport { isArray, isFunction, isNumber } from '@element-plus/utils'\nimport { tableV2RowProps } from '../row'\nimport { TableV2InjectionKey } from '../tokens'\nimport { placeholderSign } from '../private'\n\nimport type { CSSProperties, RendererElement, RendererNode, VNode } from 'vue'\nimport type { RowEventHandlers, TableV2RowProps } from '../row'\n\ntype CustomizedCellsType = VNode<\n  RendererNode,\n  RendererElement,\n  {\n    [key: string]: any\n  }\n>[]\n\ntype DefaultCellsType = VNode<\n  RendererNode,\n  RendererElement,\n  {\n    [key: string]: any\n  }\n>[][]\n\ntype ColumnCellsType = DefaultCellsType | CustomizedCellsType\n\nconst useTableRow = (props: TableV2RowProps) => {\n  const { isScrolling } = inject(TableV2InjectionKey)!\n\n  const measured = ref(false)\n  const rowRef = ref<HTMLElement>()\n  const measurable = computed(() => {\n    return isNumber(props.estimatedRowHeight) && props.rowIndex >= 0\n  })\n\n  const doMeasure = (isInit = false) => {\n    const $rowRef = unref(rowRef)\n    if (!$rowRef) return\n    const { columns, onRowHeightChange, rowKey, rowIndex, style } = props\n    const { height } = $rowRef.getBoundingClientRect()\n    measured.value = true\n\n    nextTick(() => {\n      if (isInit || height !== Number.parseInt(style!.height as string)) {\n        const firstColumn = columns[0]\n        const isPlaceholder = firstColumn?.placeholderSign === placeholderSign\n        onRowHeightChange?.(\n          { rowKey, height, rowIndex },\n          firstColumn && !isPlaceholder && firstColumn.fixed\n        )\n      }\n    })\n  }\n\n  const eventHandlers = computed(() => {\n    const { rowData, rowIndex, rowKey, onRowHover } = props\n    const handlers = props.rowEventHandlers || ({} as RowEventHandlers)\n    const eventHandlers = {} as {\n      [key in keyof RowEventHandlers]: (e: Event) => void\n    }\n\n    Object.entries(handlers).forEach(([eventName, handler]) => {\n      if (isFunction(handler)) {\n        eventHandlers[eventName as keyof RowEventHandlers] = (event: Event) => {\n          handler({\n            event,\n            rowData,\n            rowIndex,\n            rowKey,\n          })\n        }\n      }\n    })\n\n    if (onRowHover) {\n      ;(\n        [\n          { name: 'onMouseleave', hovered: false },\n          { name: 'onMouseenter', hovered: true },\n        ] as const\n      ).forEach(({ name, hovered }) => {\n        const existedHandler = eventHandlers[name]\n        eventHandlers[name] = ((event: MouseEvent) => {\n          onRowHover({\n            event,\n            hovered,\n            rowData,\n            rowIndex,\n            rowKey,\n          })\n\n          existedHandler?.(event)\n        }) as any\n      })\n    }\n    return eventHandlers\n  })\n\n  const onExpand = (expanded: boolean) => {\n    const { onRowExpand, rowData, rowIndex, rowKey } = props\n\n    onRowExpand?.({\n      expanded,\n      rowData,\n      rowIndex,\n      rowKey,\n    })\n  }\n\n  onMounted(() => {\n    if (unref(measurable)) {\n      doMeasure(true)\n    }\n  })\n\n  return { isScrolling, measurable, measured, rowRef, eventHandlers, onExpand }\n}\n\nconst COMPONENT_NAME = 'ElTableV2TableRow'\n\nconst TableV2Row = defineComponent({\n  name: COMPONENT_NAME,\n  props: tableV2RowProps,\n  setup(props, { expose, slots, attrs }) {\n    const {\n      eventHandlers,\n      isScrolling,\n      measurable,\n      measured,\n      rowRef,\n\n      onExpand,\n    } = useTableRow(props)\n\n    expose({\n      /**\n       * @description manually dispatching expand action on row.\n       */\n      onExpand,\n    })\n\n    return () => {\n      const {\n        columns,\n        columnsStyles,\n        expandColumnKey,\n        depth,\n        rowData,\n        rowIndex,\n        style,\n      } = props\n\n      let ColumnCells: ColumnCellsType = columns.map((column, columnIndex) => {\n        const expandable =\n          isArray(rowData.children) &&\n          rowData.children.length > 0 &&\n          column.key === expandColumnKey\n\n        return slots.cell!({\n          column,\n          columns,\n          columnIndex,\n          depth,\n          style: columnsStyles[column.key],\n          rowData,\n          rowIndex,\n          isScrolling: unref(isScrolling),\n          expandIconProps: expandable\n            ? {\n                rowData,\n                rowIndex,\n                onExpand,\n              }\n            : undefined,\n        })\n      })\n\n      if (slots.row) {\n        ColumnCells = slots.row({\n          cells: ColumnCells.map((node) => {\n            if (isArray(node) && node.length === 1) {\n              return node[0]\n            }\n            return node\n          }),\n          style,\n          columns,\n          depth,\n          rowData,\n          rowIndex,\n          isScrolling: unref(isScrolling),\n        })\n      }\n\n      if (unref(measurable)) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { height, ...exceptHeightStyle } = style || {}\n        const _measured = unref(measured)\n        return (\n          <div\n            ref={rowRef}\n            class={props.class}\n            style={_measured ? style : exceptHeightStyle}\n            {...attrs}\n            {...unref(eventHandlers)}\n          >\n            {ColumnCells}\n          </div>\n        )\n      }\n\n      return (\n        <div\n          {...attrs}\n          ref={rowRef}\n          class={props.class}\n          style={style}\n          {...unref(eventHandlers)}\n        >\n          {ColumnCells}\n        </div>\n      )\n    }\n  },\n})\n\nexport default TableV2Row\n\nexport type TableV2RowCellRenderParam = {\n  column: TableV2RowProps['columns'][number]\n  columns: TableV2RowProps['columns']\n  columnIndex: number\n  depth: number\n  style: CSSProperties\n  rowData: any\n  rowIndex: number\n  isScrolling: boolean\n  expandIconProps?: {\n    rowData: any\n    rowIndex: number\n    onExpand: (expand: boolean) => void\n  }\n}\n"]},"metadata":{},"sourceType":"module"}