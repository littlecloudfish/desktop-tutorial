{"ast":null,"code":"import axios from 'axios';\nimport BaseMixin from './AvBase';\n/**\n * Component props\n */\n\nconst props = {\n  /**\n   * prop: 'canv-width'\n   * Canvas element width. Default 500\n   */\n  canvWidth: {\n    type: Number,\n    default: 500\n  },\n\n  /**\n   * prop: 'canv-height'\n   * Canvas element height. Default 80\n   */\n  canvHeight: {\n    type: Number,\n    default: 80\n  },\n\n  /**\n   * prop: 'played-line-width'\n   * Waveform line width for played segment of audio\n   * Default: 0.5\n   */\n  playedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n\n  /**\n   * prop: 'played-line-color'\n   * Waveform line color for played segment of audio\n   * Default: navy\n   */\n  playedLineColor: {\n    type: String,\n    default: 'navy'\n  },\n\n  /**\n   * prop: 'noplayed-line-width'\n   * Waveform line width for not yet played segment of audio\n   * Default: 0.5\n   */\n  noplayedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n\n  /**\n   * prop: 'noplayed-line-color'\n   * Waveform line color for not yet played segment of audio\n   * Default: lime\n   */\n  noplayedLineColor: {\n    type: String,\n    default: 'lime'\n  },\n\n  /**\n   * prop: 'playtime'\n   * Display played time next to progress slider.\n   * Default: true\n   */\n  playtime: {\n    type: Boolean,\n    default: true\n  },\n\n  /**\n   * prop: 'playtime-with-ms'\n   * Display milliseconds in played when true.\n   * For example: 02:55.054\n   * Default: true\n   */\n  playtimeWithMs: {\n    type: Boolean,\n    default: true\n  },\n\n  /**\n   * prop: 'playtime-font-size'\n   * Played time print font size in pixels.\n   * Default: 12\n   */\n  playtimeFontSize: {\n    type: Number,\n    default: 12\n  },\n\n  /**\n   * prop: 'playtime-font-family'\n   * Played time print font family.\n   * Default: monospace\n   */\n  playtimeFontFamily: {\n    type: String,\n    default: 'monospace'\n  },\n\n  /**\n   * prop: 'playtime-font-color'\n   * Played time print font RGB color string.\n   * Default: grey\n   */\n  playtimeFontColor: {\n    type: String,\n    default: 'grey'\n  },\n\n  /**\n   * prop: 'playtime-text-bottom'\n   * Position playtime text bottom.\n   * Default on top.\n   * Default: false\n   */\n  playtimeTextBottom: {\n    type: Boolean,\n    default: false\n  },\n\n  /**\n   * prop: 'playtime-slider'\n   * Draw played slider\n   * Default: true\n   */\n  playtimeSlider: {\n    type: Boolean,\n    default: true\n  },\n\n  /**\n   * prop: 'playtime-slider-color'\n   * Played slider color\n   * Default: red\n   */\n  playtimeSliderColor: {\n    type: String,\n    default: 'red'\n  },\n\n  /**\n   * prop: 'playtime-slider-width'\n   * Played slider width\n   * Default: 1\n   */\n  playtimeSliderWidth: {\n    type: Number,\n    default: 1\n  },\n\n  /**\n   * prop: 'playtime-clickable'\n   * Allow click on waveform to change playtime.\n   * Default: true\n   */\n  playtimeClickable: {\n    type: Boolean,\n    default: true\n  },\n\n  /**\n   * prop: 'requester'\n   * Allow set a custom requester (axios/fetch) to be used.\n   * Default: new axios instance\n   */\n  requester: {\n    type: Function,\n    default: axios\n  }\n};\n/**\n * Component AvLine\n */\n\nconst AvWaveform = {\n  name: 'av-waveform',\n  mixins: [BaseMixin],\n  props,\n\n  data() {\n    return {\n      animId: null,\n      ctxWrapper: null,\n      ctx: null,\n      audio: null,\n      duration: null,\n      peaks: []\n    };\n  },\n\n  mounted() {\n    const conf = {\n      responseType: 'arraybuffer',\n      onDownloadProgress: this.downloadProgress\n    };\n    this.requester.get(this.audio.src, conf).then(response => this.decode(response)).catch(err => {\n      console.error(`Failed to get file '${this.audio.src}'`);\n      console.log(err);\n    });\n\n    this.audio.onplay = () => {\n      this.animId = requestAnimationFrame(this.waveformAnim);\n    };\n\n    this.audio.onpause = () => {\n      cancelAnimationFrame(this.animId);\n      this.animId = null;\n    };\n  },\n\n  methods: {\n    // Stub set analyser method from Mixin AvBase\n    // as there is no need of analyser in that component\n    // this method is called from mixin mounted()\n    setAnalyser: function () {\n      /* istanbul ignore next */\n      return null;\n    },\n    // Stub mainLoop method from Mixin AvBase as\n    // here different init method will be used.\n    // This method is called from mixin mounted()\n    mainLoop: function () {\n      /* istanbul ignore next */\n      return null;\n    },\n\n    /**\n     * Decode audio source response array buffer\n     */\n    decode: function (response) {\n      /* istanbul ignore next */\n      const ctx = new AudioContext();\n      /* istanbul ignore next */\n\n      ctx.decodeAudioData(response.data, audioBuffer => {\n        this.setPeaks(audioBuffer);\n      }, err => {\n        console.error('Failed to decode audio data.');\n        console.log(err);\n      });\n    },\n\n    /**\n     * Set peaks array for waveform.\n     * For now use only one channel\n     */\n    setPeaks: function (buffer) {\n      const peaks = [];\n      let min = 0;\n      let max = 0;\n      let top = 0;\n      let bottom = 0;\n      const segSize = Math.ceil(buffer.length / this.canvWidth);\n      const width = this.canvWidth;\n      const height = this.canvHeight;\n      this.duration = buffer.duration; // while we have buffer why we don't use it ?\n\n      for (let c = 0; c < buffer.numberOfChannels; c++) {\n        const data = buffer.getChannelData(c);\n\n        for (let s = 0; s < width; s++) {\n          const start = ~~(s * segSize);\n          const end = ~~(start + segSize);\n          min = 0;\n          max = 0;\n\n          for (let i = start; i < end; i++) {\n            min = data[i] < min ? data[i] : min;\n            max = data[i] > max ? data[i] : max;\n          } // merge multi channel data\n\n\n          if (peaks[s]) {\n            peaks[s][0] = peaks[s][0] < max ? max : peaks[s][0];\n            peaks[s][1] = peaks[s][1] > min ? min : peaks[s][1];\n          }\n\n          peaks[s] = [max, min];\n        }\n      } // set peaks relativelly to canvas dimensions\n\n\n      for (let i = 0; i < peaks.length; i++) {\n        max = peaks[i][0];\n        min = peaks[i][1];\n        top = height / 2 - max * height / 2;\n        bottom = height / 2 - min * height / 2;\n        peaks[i] = [top, bottom === top ? top + 1 : bottom];\n      }\n\n      this.peaks = peaks;\n\n      if (this.playtimeClickable) {\n        this.ctxWrapper.addEventListener('click', e => this.updateTime(e));\n      }\n\n      this.waveform();\n    },\n\n    /**\n     * Draw wave form.\n     */\n    waveform: function () {\n      const peaks = this.peaks;\n      const time = this.audio.currentTime;\n      const playX = this.playX(time);\n      let x = 0;\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight);\n      x = this.draw(peaks.slice(0, playX), this.playedLineWidth, this.playedLineColor, x);\n      this.draw(peaks.slice(playX), this.noplayedLineWidth, this.noplayedLineColor, x);\n      this.drawSlider(time);\n      if (this.playtime) this.drawTime(time);\n    },\n\n    /**\n     * Waveform animation proxy\n     */\n    waveformAnim: function () {\n      this.waveform();\n      this.animId = requestAnimationFrame(this.waveformAnim);\n    },\n\n    /**\n     * Draw segment.\n     */\n    draw: function (data, lineWidth, color, x) {\n      this.ctx.lineWidth = lineWidth;\n      this.ctx.strokeStyle = color;\n      this.ctx.beginPath();\n      data.forEach(v => {\n        this.ctx.moveTo(x, v[0]);\n        this.ctx.lineTo(x, v[1]);\n        x++;\n      });\n      this.ctx.stroke();\n      return x;\n    },\n\n    /**\n     * Formatted string of current play time.\n     * @param {Number} Current play time\n     * @return {String}\n     */\n    timeFormat: function (timeSec) {\n      let frmStr = '';\n      const time = parseFloat(timeSec);\n\n      if (isNaN(time)) {\n        return frmStr;\n      }\n\n      const min = ~~(time / 60);\n      const sec = ~~(time % 60);\n      const ms = ~~(time % 1 * 1000);\n      frmStr = min < 10 ? `0${min}:` : `${min}:`;\n      frmStr += `0${sec}`.substr(-2);\n\n      if (this.playtimeWithMs) {\n        frmStr += '.' + `00${ms}`.substr(-3);\n      }\n\n      return frmStr;\n    },\n\n    /**\n     * Draw play time next to slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawTime: function (time) {\n      const timeStr = this.timeFormat(time);\n      const offset = 3;\n      const textWidth = ~~this.ctx.measureText(timeStr).width;\n      const playX = this.playX(time);\n      const textX = playX > this.canvWidth - textWidth - offset ? playX - textWidth - offset : playX + offset;\n      const textY = this.playtimeTextBottom ? this.canvHeight - this.playtimeFontSize + offset : this.playtimeFontSize + offset;\n      this.ctx.fillStyle = this.playtimeFontColor;\n      this.ctx.font = `${this.playtimeFontSize}px ${this.playtimeFontFamily}`;\n      this.ctx.fillText(timeStr, textX, textY);\n    },\n\n    /**\n     * Draw played slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawSlider: function (time) {\n      const playX = this.playX(time);\n      this.ctx.lineWidth = this.playtimeSliderWidth;\n      this.ctx.strokeStyle = this.playtimeSliderColor;\n      this.ctx.beginPath();\n      this.ctx.moveTo(playX, 0);\n      this.ctx.lineTo(playX, this.canvHeight);\n      this.ctx.stroke();\n    },\n\n    /**\n     * Get x coodrinate for play time.\n     * @param {Number}\n     * @return {Number}\n     */\n    playX: function (time) {\n      return ~~(time / this.duration * this.canvWidth);\n    },\n\n    /**\n     * Audio playback update time callback.\n     * @param event\n     */\n    updateTime: function (e) {\n      this.audio.currentTime = e.offsetX / this.canvWidth * this.duration;\n\n      if (!this.animId) {\n        // re-draw if animation is not running\n        this.waveform();\n      }\n    },\n\n    /**\n     * Audio source download progress\n     */\n    downloadProgress: function (ev) {\n      const progressX = Math.round(ev.loaded / ev.total * this.canvWidth);\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight);\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = this.noplayedLineColor;\n      this.ctx.moveTo(0, this.canvHeight / 2);\n      this.ctx.lineTo(progressX, this.canvHeight / 2);\n      this.ctx.stroke();\n    }\n  }\n};\nexport default AvWaveform;","map":{"version":3,"names":["axios","BaseMixin","props","canvWidth","type","Number","default","canvHeight","playedLineWidth","playedLineColor","String","noplayedLineWidth","noplayedLineColor","playtime","Boolean","playtimeWithMs","playtimeFontSize","playtimeFontFamily","playtimeFontColor","playtimeTextBottom","playtimeSlider","playtimeSliderColor","playtimeSliderWidth","playtimeClickable","requester","Function","AvWaveform","name","mixins","data","animId","ctxWrapper","ctx","audio","duration","peaks","mounted","conf","responseType","onDownloadProgress","downloadProgress","get","src","then","response","decode","catch","err","console","error","log","onplay","requestAnimationFrame","waveformAnim","onpause","cancelAnimationFrame","methods","setAnalyser","mainLoop","AudioContext","decodeAudioData","audioBuffer","setPeaks","buffer","min","max","top","bottom","segSize","Math","ceil","length","width","height","c","numberOfChannels","getChannelData","s","start","end","i","addEventListener","e","updateTime","waveform","time","currentTime","playX","x","clearRect","draw","slice","drawSlider","drawTime","lineWidth","color","strokeStyle","beginPath","forEach","v","moveTo","lineTo","stroke","timeFormat","timeSec","frmStr","parseFloat","isNaN","sec","ms","substr","timeStr","offset","textWidth","measureText","textX","textY","fillStyle","font","fillText","offsetX","ev","progressX","round","loaded","total"],"sources":["/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/vue-audio-visual/src/components/AvWaveform.js"],"sourcesContent":["import axios from 'axios'\nimport BaseMixin from './AvBase'\n\n/**\n * Component props\n */\nconst props = {\n  /**\n   * prop: 'canv-width'\n   * Canvas element width. Default 500\n   */\n  canvWidth: {\n    type: Number,\n    default: 500\n  },\n  /**\n   * prop: 'canv-height'\n   * Canvas element height. Default 80\n   */\n  canvHeight: {\n    type: Number,\n    default: 80\n  },\n  /**\n   * prop: 'played-line-width'\n   * Waveform line width for played segment of audio\n   * Default: 0.5\n   */\n  playedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n  /**\n   * prop: 'played-line-color'\n   * Waveform line color for played segment of audio\n   * Default: navy\n   */\n  playedLineColor: {\n    type: String,\n    default: 'navy'\n  },\n  /**\n   * prop: 'noplayed-line-width'\n   * Waveform line width for not yet played segment of audio\n   * Default: 0.5\n   */\n  noplayedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n  /**\n   * prop: 'noplayed-line-color'\n   * Waveform line color for not yet played segment of audio\n   * Default: lime\n   */\n  noplayedLineColor: {\n    type: String,\n    default: 'lime'\n  },\n  /**\n   * prop: 'playtime'\n   * Display played time next to progress slider.\n   * Default: true\n   */\n  playtime: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-with-ms'\n   * Display milliseconds in played when true.\n   * For example: 02:55.054\n   * Default: true\n   */\n  playtimeWithMs: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-font-size'\n   * Played time print font size in pixels.\n   * Default: 12\n   */\n  playtimeFontSize: {\n    type: Number,\n    default: 12\n  },\n  /**\n   * prop: 'playtime-font-family'\n   * Played time print font family.\n   * Default: monospace\n   */\n  playtimeFontFamily: {\n    type: String,\n    default: 'monospace'\n  },\n  /**\n   * prop: 'playtime-font-color'\n   * Played time print font RGB color string.\n   * Default: grey\n   */\n  playtimeFontColor: {\n    type: String,\n    default: 'grey'\n  },\n  /**\n   * prop: 'playtime-text-bottom'\n   * Position playtime text bottom.\n   * Default on top.\n   * Default: false\n   */\n  playtimeTextBottom: {\n    type: Boolean,\n    default: false\n  },\n  /**\n   * prop: 'playtime-slider'\n   * Draw played slider\n   * Default: true\n   */\n  playtimeSlider: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-slider-color'\n   * Played slider color\n   * Default: red\n   */\n  playtimeSliderColor: {\n    type: String,\n    default: 'red'\n  },\n  /**\n   * prop: 'playtime-slider-width'\n   * Played slider width\n   * Default: 1\n   */\n  playtimeSliderWidth: {\n    type: Number,\n    default: 1\n  },\n  /**\n   * prop: 'playtime-clickable'\n   * Allow click on waveform to change playtime.\n   * Default: true\n   */\n  playtimeClickable: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'requester'\n   * Allow set a custom requester (axios/fetch) to be used.\n   * Default: new axios instance\n   */\n  requester: {\n    type: Function,\n    default: axios\n  }\n}\n\n/**\n * Component AvLine\n */\nconst AvWaveform = {\n  name: 'av-waveform',\n  mixins: [BaseMixin],\n  props,\n  data () {\n    return {\n      animId: null,\n      ctxWrapper: null,\n      ctx: null,\n      audio: null,\n      duration: null,\n      peaks: []\n    }\n  },\n  mounted () {\n    const conf = {\n      responseType: 'arraybuffer',\n      onDownloadProgress: this.downloadProgress\n    }\n    this.requester.get(this.audio.src, conf)\n      .then(response => this.decode(response))\n      .catch(err => {\n        console.error(`Failed to get file '${this.audio.src}'`)\n        console.log(err)\n      })\n    this.audio.onplay = () => {\n      this.animId = requestAnimationFrame(this.waveformAnim)\n    }\n    this.audio.onpause = () => {\n      cancelAnimationFrame(this.animId)\n      this.animId = null\n    }\n  },\n  methods: {\n    // Stub set analyser method from Mixin AvBase\n    // as there is no need of analyser in that component\n    // this method is called from mixin mounted()\n    setAnalyser: function () {\n      /* istanbul ignore next */\n      return null\n    },\n\n    // Stub mainLoop method from Mixin AvBase as\n    // here different init method will be used.\n    // This method is called from mixin mounted()\n    mainLoop: function () {\n      /* istanbul ignore next */\n      return null\n    },\n\n    /**\n     * Decode audio source response array buffer\n     */\n    decode: function (response) {\n      /* istanbul ignore next */\n      const ctx = new AudioContext()\n      /* istanbul ignore next */\n      ctx.decodeAudioData(response.data, (audioBuffer) => {\n        this.setPeaks(audioBuffer)\n      }, (err) => {\n        console.error('Failed to decode audio data.')\n        console.log(err)\n      })\n    },\n\n    /**\n     * Set peaks array for waveform.\n     * For now use only one channel\n     */\n    setPeaks: function (buffer) {\n      const peaks = []\n      let min = 0\n      let max = 0\n      let top = 0\n      let bottom = 0\n      const segSize = Math.ceil(buffer.length / this.canvWidth)\n      const width = this.canvWidth\n      const height = this.canvHeight\n      this.duration = buffer.duration // while we have buffer why we don't use it ?\n\n      for (let c = 0; c < buffer.numberOfChannels; c++) {\n        const data = buffer.getChannelData(c)\n        for (let s = 0; s < width; s++) {\n          const start = ~~(s * segSize)\n          const end = ~~(start + segSize)\n          min = 0\n          max = 0\n          for (let i = start; i < end; i++) {\n            min = data[i] < min ? data[i] : min\n            max = data[i] > max ? data[i] : max\n          }\n          // merge multi channel data\n          if (peaks[s]) {\n            peaks[s][0] = peaks[s][0] < max ? max : peaks[s][0]\n            peaks[s][1] = peaks[s][1] > min ? min : peaks[s][1]\n          }\n          peaks[s] = [max, min]\n        }\n      }\n      // set peaks relativelly to canvas dimensions\n      for (let i = 0; i < peaks.length; i++) {\n        max = peaks[i][0]\n        min = peaks[i][1]\n        top = ((height / 2) - (max * height / 2))\n        bottom = ((height / 2) - (min * height / 2))\n        peaks[i] = [top, bottom === top ? top + 1 : bottom]\n      }\n      this.peaks = peaks\n\n      if (this.playtimeClickable) {\n        this.ctxWrapper.addEventListener('click', (e) => this.updateTime(e))\n      }\n      this.waveform()\n    },\n\n    /**\n     * Draw wave form.\n     */\n    waveform: function () {\n      const peaks = this.peaks\n      const time = this.audio.currentTime\n      const playX = this.playX(time)\n      let x = 0\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight)\n      x = this.draw(peaks.slice(0, playX), this.playedLineWidth, this.playedLineColor, x)\n      this.draw(peaks.slice(playX), this.noplayedLineWidth, this.noplayedLineColor, x)\n      this.drawSlider(time)\n      if (this.playtime) this.drawTime(time)\n    },\n\n    /**\n     * Waveform animation proxy\n     */\n    waveformAnim: function () {\n      this.waveform()\n      this.animId = requestAnimationFrame(this.waveformAnim)\n    },\n\n    /**\n     * Draw segment.\n     */\n    draw: function (data, lineWidth, color, x) {\n      this.ctx.lineWidth = lineWidth\n      this.ctx.strokeStyle = color\n      this.ctx.beginPath()\n      data.forEach(v => {\n        this.ctx.moveTo(x, v[0])\n        this.ctx.lineTo(x, v[1])\n        x++\n      })\n      this.ctx.stroke()\n      return x\n    },\n\n    /**\n     * Formatted string of current play time.\n     * @param {Number} Current play time\n     * @return {String}\n     */\n    timeFormat: function (timeSec) {\n      let frmStr = ''\n      const time = parseFloat(timeSec)\n      if (isNaN(time)) {\n        return frmStr\n      }\n\n      const min = ~~(time / 60)\n      const sec = ~~(time % 60)\n      const ms = ~~(time % 1 * 1000)\n\n      frmStr = (min < 10) ? `0${min}:` : `${min}:`\n      frmStr += `0${sec}`.substr(-2)\n      if (this.playtimeWithMs) {\n        frmStr += '.' + `00${ms}`.substr(-3)\n      }\n\n      return frmStr\n    },\n\n    /**\n     * Draw play time next to slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawTime: function (time) {\n      const timeStr = this.timeFormat(time)\n      const offset = 3\n      const textWidth = ~~this.ctx.measureText(timeStr).width\n      const playX = this.playX(time)\n      const textX = playX > (this.canvWidth - textWidth - offset)\n        ? playX - textWidth - offset\n        : playX + offset\n      const textY = this.playtimeTextBottom\n        ? this.canvHeight - this.playtimeFontSize + offset\n        : this.playtimeFontSize + offset\n      this.ctx.fillStyle = this.playtimeFontColor\n      this.ctx.font = `${this.playtimeFontSize}px ${this.playtimeFontFamily}`\n      this.ctx.fillText(timeStr, textX, textY)\n    },\n\n    /**\n     * Draw played slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawSlider: function (time) {\n      const playX = this.playX(time)\n      this.ctx.lineWidth = this.playtimeSliderWidth\n      this.ctx.strokeStyle = this.playtimeSliderColor\n      this.ctx.beginPath()\n      this.ctx.moveTo(playX, 0)\n      this.ctx.lineTo(playX, this.canvHeight)\n      this.ctx.stroke()\n    },\n\n    /**\n     * Get x coodrinate for play time.\n     * @param {Number}\n     * @return {Number}\n     */\n    playX: function (time) {\n      return ~~(time / this.duration * this.canvWidth)\n    },\n\n    /**\n     * Audio playback update time callback.\n     * @param event\n     */\n    updateTime: function (e) {\n      this.audio.currentTime = e.offsetX / this.canvWidth * this.duration\n      if (!this.animId) {\n        // re-draw if animation is not running\n        this.waveform()\n      }\n    },\n\n    /**\n     * Audio source download progress\n     */\n    downloadProgress: function (ev) {\n      const progressX = Math.round(ev.loaded / ev.total * this.canvWidth)\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight)\n      this.ctx.beginPath()\n      this.ctx.strokeStyle = this.noplayedLineColor\n      this.ctx.moveTo(0, this.canvHeight / 2)\n      this.ctx.lineTo(progressX, this.canvHeight / 2)\n      this.ctx.stroke()\n    }\n  }\n}\nexport default AvWaveform\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}