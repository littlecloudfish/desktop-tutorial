{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport axios from 'axios';\nimport BaseMixin from './AvBase';\n/**\n * Component props\n */\n\nvar props = {\n  /**\n   * prop: 'canv-width'\n   * Canvas element width. Default 500\n   */\n  canvWidth: {\n    type: Number,\n    \"default\": 500\n  },\n\n  /**\n   * prop: 'canv-height'\n   * Canvas element height. Default 80\n   */\n  canvHeight: {\n    type: Number,\n    \"default\": 80\n  },\n\n  /**\n   * prop: 'played-line-width'\n   * Waveform line width for played segment of audio\n   * Default: 0.5\n   */\n  playedLineWidth: {\n    type: Number,\n    \"default\": 0.5\n  },\n\n  /**\n   * prop: 'played-line-color'\n   * Waveform line color for played segment of audio\n   * Default: navy\n   */\n  playedLineColor: {\n    type: String,\n    \"default\": 'navy'\n  },\n\n  /**\n   * prop: 'noplayed-line-width'\n   * Waveform line width for not yet played segment of audio\n   * Default: 0.5\n   */\n  noplayedLineWidth: {\n    type: Number,\n    \"default\": 0.5\n  },\n\n  /**\n   * prop: 'noplayed-line-color'\n   * Waveform line color for not yet played segment of audio\n   * Default: lime\n   */\n  noplayedLineColor: {\n    type: String,\n    \"default\": 'lime'\n  },\n\n  /**\n   * prop: 'playtime'\n   * Display played time next to progress slider.\n   * Default: true\n   */\n  playtime: {\n    type: Boolean,\n    \"default\": true\n  },\n\n  /**\n   * prop: 'playtime-with-ms'\n   * Display milliseconds in played when true.\n   * For example: 02:55.054\n   * Default: true\n   */\n  playtimeWithMs: {\n    type: Boolean,\n    \"default\": true\n  },\n\n  /**\n   * prop: 'playtime-font-size'\n   * Played time print font size in pixels.\n   * Default: 12\n   */\n  playtimeFontSize: {\n    type: Number,\n    \"default\": 12\n  },\n\n  /**\n   * prop: 'playtime-font-family'\n   * Played time print font family.\n   * Default: monospace\n   */\n  playtimeFontFamily: {\n    type: String,\n    \"default\": 'monospace'\n  },\n\n  /**\n   * prop: 'playtime-font-color'\n   * Played time print font RGB color string.\n   * Default: grey\n   */\n  playtimeFontColor: {\n    type: String,\n    \"default\": 'grey'\n  },\n\n  /**\n   * prop: 'playtime-text-bottom'\n   * Position playtime text bottom.\n   * Default on top.\n   * Default: false\n   */\n  playtimeTextBottom: {\n    type: Boolean,\n    \"default\": false\n  },\n\n  /**\n   * prop: 'playtime-slider'\n   * Draw played slider\n   * Default: true\n   */\n  playtimeSlider: {\n    type: Boolean,\n    \"default\": true\n  },\n\n  /**\n   * prop: 'playtime-slider-color'\n   * Played slider color\n   * Default: red\n   */\n  playtimeSliderColor: {\n    type: String,\n    \"default\": 'red'\n  },\n\n  /**\n   * prop: 'playtime-slider-width'\n   * Played slider width\n   * Default: 1\n   */\n  playtimeSliderWidth: {\n    type: Number,\n    \"default\": 1\n  },\n\n  /**\n   * prop: 'playtime-clickable'\n   * Allow click on waveform to change playtime.\n   * Default: true\n   */\n  playtimeClickable: {\n    type: Boolean,\n    \"default\": true\n  },\n\n  /**\n   * prop: 'requester'\n   * Allow set a custom requester (axios/fetch) to be used.\n   * Default: new axios instance\n   */\n  requester: {\n    type: Function,\n    \"default\": axios\n  }\n};\n/**\n * Component AvLine\n */\n\nvar AvWaveform = {\n  name: 'av-waveform',\n  mixins: [BaseMixin],\n  props: props,\n  data: function data() {\n    return {\n      animId: null,\n      ctxWrapper: null,\n      ctx: null,\n      audio: null,\n      duration: null,\n      peaks: []\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    var conf = {\n      responseType: 'arraybuffer',\n      onDownloadProgress: this.downloadProgress\n    };\n    this.requester.get(this.audio.src, conf).then(function (response) {\n      return _this.decode(response);\n    })[\"catch\"](function (err) {\n      console.error(\"Failed to get file '\".concat(_this.audio.src, \"'\"));\n      console.log(err);\n    });\n\n    this.audio.onplay = function () {\n      _this.animId = requestAnimationFrame(_this.waveformAnim);\n    };\n\n    this.audio.onpause = function () {\n      cancelAnimationFrame(_this.animId);\n      _this.animId = null;\n    };\n  },\n  methods: {\n    // Stub set analyser method from Mixin AvBase\n    // as there is no need of analyser in that component\n    // this method is called from mixin mounted()\n    setAnalyser: function setAnalyser() {\n      /* istanbul ignore next */\n      return null;\n    },\n    // Stub mainLoop method from Mixin AvBase as\n    // here different init method will be used.\n    // This method is called from mixin mounted()\n    mainLoop: function mainLoop() {\n      /* istanbul ignore next */\n      return null;\n    },\n\n    /**\n     * Decode audio source response array buffer\n     */\n    decode: function decode(response) {\n      var _this2 = this;\n\n      /* istanbul ignore next */\n      var ctx = new AudioContext();\n      /* istanbul ignore next */\n\n      ctx.decodeAudioData(response.data, function (audioBuffer) {\n        _this2.setPeaks(audioBuffer);\n      }, function (err) {\n        console.error('Failed to decode audio data.');\n        console.log(err);\n      });\n    },\n\n    /**\n     * Set peaks array for waveform.\n     * For now use only one channel\n     */\n    setPeaks: function setPeaks(buffer) {\n      var _this3 = this;\n\n      var peaks = [];\n      var min = 0;\n      var max = 0;\n      var top = 0;\n      var bottom = 0;\n      var segSize = Math.ceil(buffer.length / this.canvWidth);\n      var width = this.canvWidth;\n      var height = this.canvHeight;\n      this.duration = buffer.duration; // while we have buffer why we don't use it ?\n\n      for (var c = 0; c < buffer.numberOfChannels; c++) {\n        var data = buffer.getChannelData(c);\n\n        for (var s = 0; s < width; s++) {\n          var start = ~~(s * segSize);\n          var end = ~~(start + segSize);\n          min = 0;\n          max = 0;\n\n          for (var i = start; i < end; i++) {\n            min = data[i] < min ? data[i] : min;\n            max = data[i] > max ? data[i] : max;\n          } // merge multi channel data\n\n\n          if (peaks[s]) {\n            peaks[s][0] = peaks[s][0] < max ? max : peaks[s][0];\n            peaks[s][1] = peaks[s][1] > min ? min : peaks[s][1];\n          }\n\n          peaks[s] = [max, min];\n        }\n      } // set peaks relativelly to canvas dimensions\n\n\n      for (var _i = 0; _i < peaks.length; _i++) {\n        max = peaks[_i][0];\n        min = peaks[_i][1];\n        top = height / 2 - max * height / 2;\n        bottom = height / 2 - min * height / 2;\n        peaks[_i] = [top, bottom === top ? top + 1 : bottom];\n      }\n\n      this.peaks = peaks;\n\n      if (this.playtimeClickable) {\n        this.ctxWrapper.addEventListener('click', function (e) {\n          return _this3.updateTime(e);\n        });\n      }\n\n      this.waveform();\n    },\n\n    /**\n     * Draw wave form.\n     */\n    waveform: function waveform() {\n      var peaks = this.peaks;\n      var time = this.audio.currentTime;\n      var playX = this.playX(time);\n      var x = 0;\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight);\n      x = this.draw(peaks.slice(0, playX), this.playedLineWidth, this.playedLineColor, x);\n      this.draw(peaks.slice(playX), this.noplayedLineWidth, this.noplayedLineColor, x);\n      this.drawSlider(time);\n      if (this.playtime) this.drawTime(time);\n    },\n\n    /**\n     * Waveform animation proxy\n     */\n    waveformAnim: function waveformAnim() {\n      this.waveform();\n      this.animId = requestAnimationFrame(this.waveformAnim);\n    },\n\n    /**\n     * Draw segment.\n     */\n    draw: function draw(data, lineWidth, color, x) {\n      var _this4 = this;\n\n      this.ctx.lineWidth = lineWidth;\n      this.ctx.strokeStyle = color;\n      this.ctx.beginPath();\n      data.forEach(function (v) {\n        _this4.ctx.moveTo(x, v[0]);\n\n        _this4.ctx.lineTo(x, v[1]);\n\n        x++;\n      });\n      this.ctx.stroke();\n      return x;\n    },\n\n    /**\n     * Formatted string of current play time.\n     * @param {Number} Current play time\n     * @return {String}\n     */\n    timeFormat: function timeFormat(timeSec) {\n      var frmStr = '';\n      var time = parseFloat(timeSec);\n\n      if (isNaN(time)) {\n        return frmStr;\n      }\n\n      var min = ~~(time / 60);\n      var sec = ~~(time % 60);\n      var ms = ~~(time % 1 * 1000);\n      frmStr = min < 10 ? \"0\".concat(min, \":\") : \"\".concat(min, \":\");\n      frmStr += \"0\".concat(sec).substr(-2);\n\n      if (this.playtimeWithMs) {\n        frmStr += '.' + \"00\".concat(ms).substr(-3);\n      }\n\n      return frmStr;\n    },\n\n    /**\n     * Draw play time next to slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawTime: function drawTime(time) {\n      var timeStr = this.timeFormat(time);\n      var offset = 3;\n      var textWidth = ~~this.ctx.measureText(timeStr).width;\n      var playX = this.playX(time);\n      var textX = playX > this.canvWidth - textWidth - offset ? playX - textWidth - offset : playX + offset;\n      var textY = this.playtimeTextBottom ? this.canvHeight - this.playtimeFontSize + offset : this.playtimeFontSize + offset;\n      this.ctx.fillStyle = this.playtimeFontColor;\n      this.ctx.font = \"\".concat(this.playtimeFontSize, \"px \").concat(this.playtimeFontFamily);\n      this.ctx.fillText(timeStr, textX, textY);\n    },\n\n    /**\n     * Draw played slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawSlider: function drawSlider(time) {\n      var playX = this.playX(time);\n      this.ctx.lineWidth = this.playtimeSliderWidth;\n      this.ctx.strokeStyle = this.playtimeSliderColor;\n      this.ctx.beginPath();\n      this.ctx.moveTo(playX, 0);\n      this.ctx.lineTo(playX, this.canvHeight);\n      this.ctx.stroke();\n    },\n\n    /**\n     * Get x coodrinate for play time.\n     * @param {Number}\n     * @return {Number}\n     */\n    playX: function playX(time) {\n      return ~~(time / this.duration * this.canvWidth);\n    },\n\n    /**\n     * Audio playback update time callback.\n     * @param event\n     */\n    updateTime: function updateTime(e) {\n      this.audio.currentTime = e.offsetX / this.canvWidth * this.duration;\n\n      if (!this.animId) {\n        // re-draw if animation is not running\n        this.waveform();\n      }\n    },\n\n    /**\n     * Audio source download progress\n     */\n    downloadProgress: function downloadProgress(ev) {\n      var progressX = Math.round(ev.loaded / ev.total * this.canvWidth);\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight);\n      this.ctx.beginPath();\n      this.ctx.strokeStyle = this.noplayedLineColor;\n      this.ctx.moveTo(0, this.canvHeight / 2);\n      this.ctx.lineTo(progressX, this.canvHeight / 2);\n      this.ctx.stroke();\n    }\n  }\n};\nexport default AvWaveform;","map":{"version":3,"names":["axios","BaseMixin","props","canvWidth","type","Number","canvHeight","playedLineWidth","playedLineColor","String","noplayedLineWidth","noplayedLineColor","playtime","Boolean","playtimeWithMs","playtimeFontSize","playtimeFontFamily","playtimeFontColor","playtimeTextBottom","playtimeSlider","playtimeSliderColor","playtimeSliderWidth","playtimeClickable","requester","Function","AvWaveform","name","mixins","data","animId","ctxWrapper","ctx","audio","duration","peaks","mounted","conf","responseType","onDownloadProgress","downloadProgress","get","src","then","response","decode","err","console","error","log","onplay","requestAnimationFrame","waveformAnim","onpause","cancelAnimationFrame","methods","setAnalyser","mainLoop","AudioContext","decodeAudioData","audioBuffer","setPeaks","buffer","min","max","top","bottom","segSize","Math","ceil","length","width","height","c","numberOfChannels","getChannelData","s","start","end","i","addEventListener","e","updateTime","waveform","time","currentTime","playX","x","clearRect","draw","slice","drawSlider","drawTime","lineWidth","color","strokeStyle","beginPath","forEach","v","moveTo","lineTo","stroke","timeFormat","timeSec","frmStr","parseFloat","isNaN","sec","ms","substr","timeStr","offset","textWidth","measureText","textX","textY","fillStyle","font","fillText","offsetX","ev","progressX","round","loaded","total"],"sources":["/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/vue-audio-visual/src/components/AvWaveform.js"],"sourcesContent":["import axios from 'axios'\nimport BaseMixin from './AvBase'\n\n/**\n * Component props\n */\nconst props = {\n  /**\n   * prop: 'canv-width'\n   * Canvas element width. Default 500\n   */\n  canvWidth: {\n    type: Number,\n    default: 500\n  },\n  /**\n   * prop: 'canv-height'\n   * Canvas element height. Default 80\n   */\n  canvHeight: {\n    type: Number,\n    default: 80\n  },\n  /**\n   * prop: 'played-line-width'\n   * Waveform line width for played segment of audio\n   * Default: 0.5\n   */\n  playedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n  /**\n   * prop: 'played-line-color'\n   * Waveform line color for played segment of audio\n   * Default: navy\n   */\n  playedLineColor: {\n    type: String,\n    default: 'navy'\n  },\n  /**\n   * prop: 'noplayed-line-width'\n   * Waveform line width for not yet played segment of audio\n   * Default: 0.5\n   */\n  noplayedLineWidth: {\n    type: Number,\n    default: 0.5\n  },\n  /**\n   * prop: 'noplayed-line-color'\n   * Waveform line color for not yet played segment of audio\n   * Default: lime\n   */\n  noplayedLineColor: {\n    type: String,\n    default: 'lime'\n  },\n  /**\n   * prop: 'playtime'\n   * Display played time next to progress slider.\n   * Default: true\n   */\n  playtime: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-with-ms'\n   * Display milliseconds in played when true.\n   * For example: 02:55.054\n   * Default: true\n   */\n  playtimeWithMs: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-font-size'\n   * Played time print font size in pixels.\n   * Default: 12\n   */\n  playtimeFontSize: {\n    type: Number,\n    default: 12\n  },\n  /**\n   * prop: 'playtime-font-family'\n   * Played time print font family.\n   * Default: monospace\n   */\n  playtimeFontFamily: {\n    type: String,\n    default: 'monospace'\n  },\n  /**\n   * prop: 'playtime-font-color'\n   * Played time print font RGB color string.\n   * Default: grey\n   */\n  playtimeFontColor: {\n    type: String,\n    default: 'grey'\n  },\n  /**\n   * prop: 'playtime-text-bottom'\n   * Position playtime text bottom.\n   * Default on top.\n   * Default: false\n   */\n  playtimeTextBottom: {\n    type: Boolean,\n    default: false\n  },\n  /**\n   * prop: 'playtime-slider'\n   * Draw played slider\n   * Default: true\n   */\n  playtimeSlider: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'playtime-slider-color'\n   * Played slider color\n   * Default: red\n   */\n  playtimeSliderColor: {\n    type: String,\n    default: 'red'\n  },\n  /**\n   * prop: 'playtime-slider-width'\n   * Played slider width\n   * Default: 1\n   */\n  playtimeSliderWidth: {\n    type: Number,\n    default: 1\n  },\n  /**\n   * prop: 'playtime-clickable'\n   * Allow click on waveform to change playtime.\n   * Default: true\n   */\n  playtimeClickable: {\n    type: Boolean,\n    default: true\n  },\n  /**\n   * prop: 'requester'\n   * Allow set a custom requester (axios/fetch) to be used.\n   * Default: new axios instance\n   */\n  requester: {\n    type: Function,\n    default: axios\n  }\n}\n\n/**\n * Component AvLine\n */\nconst AvWaveform = {\n  name: 'av-waveform',\n  mixins: [BaseMixin],\n  props,\n  data () {\n    return {\n      animId: null,\n      ctxWrapper: null,\n      ctx: null,\n      audio: null,\n      duration: null,\n      peaks: []\n    }\n  },\n  mounted () {\n    const conf = {\n      responseType: 'arraybuffer',\n      onDownloadProgress: this.downloadProgress\n    }\n    this.requester.get(this.audio.src, conf)\n      .then(response => this.decode(response))\n      .catch(err => {\n        console.error(`Failed to get file '${this.audio.src}'`)\n        console.log(err)\n      })\n    this.audio.onplay = () => {\n      this.animId = requestAnimationFrame(this.waveformAnim)\n    }\n    this.audio.onpause = () => {\n      cancelAnimationFrame(this.animId)\n      this.animId = null\n    }\n  },\n  methods: {\n    // Stub set analyser method from Mixin AvBase\n    // as there is no need of analyser in that component\n    // this method is called from mixin mounted()\n    setAnalyser: function () {\n      /* istanbul ignore next */\n      return null\n    },\n\n    // Stub mainLoop method from Mixin AvBase as\n    // here different init method will be used.\n    // This method is called from mixin mounted()\n    mainLoop: function () {\n      /* istanbul ignore next */\n      return null\n    },\n\n    /**\n     * Decode audio source response array buffer\n     */\n    decode: function (response) {\n      /* istanbul ignore next */\n      const ctx = new AudioContext()\n      /* istanbul ignore next */\n      ctx.decodeAudioData(response.data, (audioBuffer) => {\n        this.setPeaks(audioBuffer)\n      }, (err) => {\n        console.error('Failed to decode audio data.')\n        console.log(err)\n      })\n    },\n\n    /**\n     * Set peaks array for waveform.\n     * For now use only one channel\n     */\n    setPeaks: function (buffer) {\n      const peaks = []\n      let min = 0\n      let max = 0\n      let top = 0\n      let bottom = 0\n      const segSize = Math.ceil(buffer.length / this.canvWidth)\n      const width = this.canvWidth\n      const height = this.canvHeight\n      this.duration = buffer.duration // while we have buffer why we don't use it ?\n\n      for (let c = 0; c < buffer.numberOfChannels; c++) {\n        const data = buffer.getChannelData(c)\n        for (let s = 0; s < width; s++) {\n          const start = ~~(s * segSize)\n          const end = ~~(start + segSize)\n          min = 0\n          max = 0\n          for (let i = start; i < end; i++) {\n            min = data[i] < min ? data[i] : min\n            max = data[i] > max ? data[i] : max\n          }\n          // merge multi channel data\n          if (peaks[s]) {\n            peaks[s][0] = peaks[s][0] < max ? max : peaks[s][0]\n            peaks[s][1] = peaks[s][1] > min ? min : peaks[s][1]\n          }\n          peaks[s] = [max, min]\n        }\n      }\n      // set peaks relativelly to canvas dimensions\n      for (let i = 0; i < peaks.length; i++) {\n        max = peaks[i][0]\n        min = peaks[i][1]\n        top = ((height / 2) - (max * height / 2))\n        bottom = ((height / 2) - (min * height / 2))\n        peaks[i] = [top, bottom === top ? top + 1 : bottom]\n      }\n      this.peaks = peaks\n\n      if (this.playtimeClickable) {\n        this.ctxWrapper.addEventListener('click', (e) => this.updateTime(e))\n      }\n      this.waveform()\n    },\n\n    /**\n     * Draw wave form.\n     */\n    waveform: function () {\n      const peaks = this.peaks\n      const time = this.audio.currentTime\n      const playX = this.playX(time)\n      let x = 0\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight)\n      x = this.draw(peaks.slice(0, playX), this.playedLineWidth, this.playedLineColor, x)\n      this.draw(peaks.slice(playX), this.noplayedLineWidth, this.noplayedLineColor, x)\n      this.drawSlider(time)\n      if (this.playtime) this.drawTime(time)\n    },\n\n    /**\n     * Waveform animation proxy\n     */\n    waveformAnim: function () {\n      this.waveform()\n      this.animId = requestAnimationFrame(this.waveformAnim)\n    },\n\n    /**\n     * Draw segment.\n     */\n    draw: function (data, lineWidth, color, x) {\n      this.ctx.lineWidth = lineWidth\n      this.ctx.strokeStyle = color\n      this.ctx.beginPath()\n      data.forEach(v => {\n        this.ctx.moveTo(x, v[0])\n        this.ctx.lineTo(x, v[1])\n        x++\n      })\n      this.ctx.stroke()\n      return x\n    },\n\n    /**\n     * Formatted string of current play time.\n     * @param {Number} Current play time\n     * @return {String}\n     */\n    timeFormat: function (timeSec) {\n      let frmStr = ''\n      const time = parseFloat(timeSec)\n      if (isNaN(time)) {\n        return frmStr\n      }\n\n      const min = ~~(time / 60)\n      const sec = ~~(time % 60)\n      const ms = ~~(time % 1 * 1000)\n\n      frmStr = (min < 10) ? `0${min}:` : `${min}:`\n      frmStr += `0${sec}`.substr(-2)\n      if (this.playtimeWithMs) {\n        frmStr += '.' + `00${ms}`.substr(-3)\n      }\n\n      return frmStr\n    },\n\n    /**\n     * Draw play time next to slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawTime: function (time) {\n      const timeStr = this.timeFormat(time)\n      const offset = 3\n      const textWidth = ~~this.ctx.measureText(timeStr).width\n      const playX = this.playX(time)\n      const textX = playX > (this.canvWidth - textWidth - offset)\n        ? playX - textWidth - offset\n        : playX + offset\n      const textY = this.playtimeTextBottom\n        ? this.canvHeight - this.playtimeFontSize + offset\n        : this.playtimeFontSize + offset\n      this.ctx.fillStyle = this.playtimeFontColor\n      this.ctx.font = `${this.playtimeFontSize}px ${this.playtimeFontFamily}`\n      this.ctx.fillText(timeStr, textX, textY)\n    },\n\n    /**\n     * Draw played slider.\n     * @param {Number} Played time sec.millisec.\n     * @return {Void}\n     */\n    drawSlider: function (time) {\n      const playX = this.playX(time)\n      this.ctx.lineWidth = this.playtimeSliderWidth\n      this.ctx.strokeStyle = this.playtimeSliderColor\n      this.ctx.beginPath()\n      this.ctx.moveTo(playX, 0)\n      this.ctx.lineTo(playX, this.canvHeight)\n      this.ctx.stroke()\n    },\n\n    /**\n     * Get x coodrinate for play time.\n     * @param {Number}\n     * @return {Number}\n     */\n    playX: function (time) {\n      return ~~(time / this.duration * this.canvWidth)\n    },\n\n    /**\n     * Audio playback update time callback.\n     * @param event\n     */\n    updateTime: function (e) {\n      this.audio.currentTime = e.offsetX / this.canvWidth * this.duration\n      if (!this.animId) {\n        // re-draw if animation is not running\n        this.waveform()\n      }\n    },\n\n    /**\n     * Audio source download progress\n     */\n    downloadProgress: function (ev) {\n      const progressX = Math.round(ev.loaded / ev.total * this.canvWidth)\n      this.ctx.clearRect(0, 0, this.canvWidth, this.canvHeight)\n      this.ctx.beginPath()\n      this.ctx.strokeStyle = this.noplayedLineColor\n      this.ctx.moveTo(0, this.canvHeight / 2)\n      this.ctx.lineTo(progressX, this.canvHeight / 2)\n      this.ctx.stroke()\n    }\n  }\n}\nexport default AvWaveform\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}