{"ast":null,"code":"import _typeof from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport { isFunction } from '@vue/shared';\nimport '../../../../utils/index.mjs';\nimport createGrid from '../builders/build-grid.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE } from '../defaults.mjs';\nimport { isUndefined } from '../../../../utils/types.mjs';\nimport { isNumber } from '@vueuse/core';\nimport { throwError } from '../../../../utils/error.mjs';\nvar max = Math.max,\n    min = Math.min,\n    floor = Math.floor;\nvar SCOPE = \"ElDynamicSizeGrid\";\nvar ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nvar ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\n\nvar getItemFromCache = function getItemFromCache(props, index, gridCache, type) {\n  var _ref = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]],\n      cachedItems = _ref[0],\n      sizer = _ref[1],\n      lastVisited = _ref[2];\n\n  if (index > lastVisited) {\n    var offset = 0;\n\n    if (lastVisited >= 0) {\n      var item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n\n    for (var i = lastVisited + 1; i <= index; i++) {\n      var size = sizer(i);\n      cachedItems[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n\n  return cachedItems[index];\n};\n\nvar bs = function bs(props, gridCache, low, high, offset, type) {\n  while (low <= high) {\n    var mid = low + floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  return max(0, low - 1);\n};\n\nvar es = function es(props, gridCache, idx, offset, type) {\n  var total = type === \"column\" ? props.totalColumn : props.totalRow;\n  var exponent = 1;\n\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\n\nvar findItem = function findItem(props, gridCache, offset, type) {\n  var _ref2 = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]],\n      cache = _ref2[0],\n      lastVisitedIndex = _ref2[1];\n  var lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref3, _ref4) {\n  var totalRow = _ref3.totalRow;\n  var estimatedRowHeight = _ref4.estimatedRowHeight,\n      lastVisitedRowIndex = _ref4.lastVisitedRowIndex,\n      row = _ref4.row;\n  var sizeOfVisitedRows = 0;\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    var item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n\n  var unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  var sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref5, _ref6) {\n  var totalColumn = _ref5.totalColumn;\n  var column = _ref6.column,\n      estimatedColumnWidth = _ref6.estimatedColumnWidth,\n      lastVisitedColumnIndex = _ref6.lastVisitedColumnIndex;\n  var sizeOfVisitedColumns = 0;\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    var item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n\n  var unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  var sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\n\nvar ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\n\nvar getOffset = function getOffset(props, index, alignment, scrollOffset, cache, type, scrollBarWidth) {\n  var _ref7 = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]],\n      size = _ref7[0],\n      estimatedSizeAssociates = _ref7[1];\n  var item = getItemFromCache(props, index, cache, type);\n  var estimatedSize = estimatedSizeAssociates(props, cache);\n  var maxOffset = max(0, min(estimatedSize - size, item.offset));\n  var minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\n\nvar DynamicSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: function getColumnPosition(props, idx, cache) {\n    var item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: function getRowPosition(props, idx, cache) {\n    var item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: function getColumnOffset(props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) {\n    return getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth);\n  },\n  getRowOffset: function getRowOffset(props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) {\n    return getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth);\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, cache) {\n    return findItem(props, cache, scrollLeft, \"column\");\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, cache) {\n    var item = getItemFromCache(props, startIndex, cache, \"column\");\n    var maxOffset = scrollLeft + props.width;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n\n    return stopIndex;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, cache) {\n    return findItem(props, cache, scrollTop, \"row\");\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, cache) {\n    var totalRow = props.totalRow,\n        height = props.height;\n    var item = getItemFromCache(props, startIndex, cache, \"row\");\n    var maxOffset = scrollTop + height;\n    var offset = item.size + item.offset;\n    var stopIndex = startIndex;\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n\n    return stopIndex;\n  },\n  injectToInstance: function injectToInstance(instance, cache) {\n    var resetAfter = function resetAfter(_ref8, forceUpdate) {\n      var columnIndex = _ref8.columnIndex,\n          rowIndex = _ref8.rowIndex;\n\n      var _a, _b;\n\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;\n\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(cache.value.lastVisitedColumnIndex, columnIndex - 1);\n      }\n\n      if (isNumber(rowIndex)) {\n        cache.value.lastVisitedRowIndex = Math.min(cache.value.lastVisitedRowIndex, rowIndex - 1);\n      }\n\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);\n      if (forceUpdate) (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n    };\n\n    var resetAfterColumnIndex = function resetAfterColumnIndex(columnIndex, forceUpdate) {\n      resetAfter({\n        columnIndex: columnIndex\n      }, forceUpdate);\n    };\n\n    var resetAfterRowIndex = function resetAfterRowIndex(rowIndex, forceUpdate) {\n      resetAfter({\n        rowIndex: rowIndex\n      }, forceUpdate);\n    };\n\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex: resetAfterColumnIndex,\n      resetAfterRowIndex: resetAfterRowIndex,\n      resetAfter: resetAfter\n    });\n  },\n  initCache: function initCache(_ref9) {\n    var _ref9$estimatedColumn = _ref9.estimatedColumnWidth,\n        estimatedColumnWidth = _ref9$estimatedColumn === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref9$estimatedColumn,\n        _ref9$estimatedRowHei = _ref9.estimatedRowHeight,\n        estimatedRowHeight = _ref9$estimatedRowHei === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref9$estimatedRowHei;\n    var cache = {\n      column: {},\n      estimatedColumnWidth: estimatedColumnWidth,\n      estimatedRowHeight: estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref10) {\n    var columnWidth = _ref10.columnWidth,\n        rowHeight = _ref10.rowHeight;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, \"\\n          \\\"columnWidth\\\" must be passed as function,\\n            instead \".concat(_typeof(columnWidth), \" was given.\\n        \"));\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, \"\\n          \\\"rowHeight\\\" must be passed as function,\\n            instead \".concat(_typeof(rowHeight), \" was given.\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeGrid as default };","map":{"version":3,"mappings":"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","names":["max","Math","min","floor","SCOPE","ACCESS_SIZER_KEY_MAP","column","row","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache","props","index","gridCache","type","cachedItems","sizer","lastVisited","offset","item","size","i","bs","low","high","mid","currentOffset","es","idx","total","totalColumn","totalRow","exponent","findItem","cache","lastVisitedIndex","lastVisitedItemOffset","getEstimatedTotalHeight","estimatedRowHeight","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","getEstimatedTotalWidth","estimatedColumnWidth","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","getOffset","alignment","scrollOffset","scrollBarWidth","height","width","estimatedSizeAssociates","estimatedSize","maxOffset","minOffset","SMART_ALIGNMENT","AUTO_ALIGNMENT","CENTERED_ALIGNMENT","START_ALIGNMENT","END_ALIGNMENT","round","DynamicSizeGrid","createGrid","name","getColumnPosition","getRowPosition","getColumnOffset","columnIndex","scrollLeft","getRowOffset","rowIndex","scrollTop","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","startIndex","stopIndex","getRowStartIndexForOffset","getRowStopIndexForStartIndex","injectToInstance","instance","resetAfter","forceUpdate","_a","_b","isUndefined","isNumber","value","exposed","getItemStyleCache","proxy","$forceUpdate","resetAfterColumnIndex","resetAfterRowIndex","Object","assign","initCache","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","clearCache","validateProps","columnWidth","rowHeight","process","env","NODE_ENV","isFunction","throwError"],"sources":["../../../../../../../packages/components/virtual-list/src/components/dynamic-size-grid.ts"],"sourcesContent":["// @ts-nocheck\nimport { isFunction } from '@vue/shared'\nimport { isNumber, isUndefined, throwError } from '@element-plus/utils'\nimport createGrid from '../builders/build-grid'\n\nimport {\n  AUTO_ALIGNMENT,\n  CENTERED_ALIGNMENT,\n  DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  END_ALIGNMENT,\n  SMART_ALIGNMENT,\n  START_ALIGNMENT,\n} from '../defaults'\nimport type { GridInstance } from '../builders/build-grid'\nimport type { VirtualizedGridProps } from '../props'\n\nimport type { Alignment, GridCache, ItemSize, ListItem } from '../types'\n\nconst { max, min, floor } = Math\nconst SCOPE = 'ElDynamicSizeGrid'\n\ntype Props = VirtualizedGridProps\ntype CacheItemType = 'column' | 'row'\ntype Indices = {\n  columnIndex?: number\n  rowIndex?: number\n}\n\n// generates props access key via type\nconst ACCESS_SIZER_KEY_MAP = {\n  column: 'columnWidth',\n  row: 'rowHeight',\n}\n\n// generates cache access key via type\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: 'lastVisitedColumnIndex',\n  row: 'lastVisitedRowIndex',\n}\n\nconst getItemFromCache = (\n  props: Props,\n  index: number,\n  gridCache: GridCache,\n  type: CacheItemType\n) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, ItemSize, number]\n\n  if (index > lastVisited) {\n    let offset = 0\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited]\n      offset = item.offset + item.size\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      // console.log(i, sizer(i))\n      const size = sizer(i)\n\n      cachedItems[i] = {\n        offset,\n        size,\n      }\n\n      offset += size\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index\n  }\n\n  return cachedItems[index]\n}\n\nconst bs = (\n  props: Props,\n  gridCache: GridCache,\n  low: number,\n  high: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2)\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset\n\n    if (currentOffset === offset) {\n      return mid\n    } else if (currentOffset < offset) {\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  return max(0, low - 1)\n}\n\nconst es = (\n  props: Props,\n  gridCache: GridCache,\n  idx: number,\n  offset: number,\n  type: CacheItemType\n) => {\n  const total = type === 'column' ? props.totalColumn : props.totalRow\n  let exponent = 1\n\n  while (\n    idx < total &&\n    getItemFromCache(props, idx, gridCache, type).offset < offset\n  ) {\n    idx += exponent\n    exponent *= 2\n  }\n\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type)\n}\n\nconst findItem = (\n  props: Props,\n  gridCache: GridCache,\n  offset: number,\n  type: CacheItemType\n) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]],\n  ] as [Record<string, ListItem>, number]\n\n  const lastVisitedItemOffset =\n    lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type)\n  }\n\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type)\n}\n\nconst getEstimatedTotalHeight = (\n  { totalRow }: Props,\n  { estimatedRowHeight, lastVisitedRowIndex, row }: GridCache\n) => {\n  let sizeOfVisitedRows = 0\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex]\n    sizeOfVisitedRows = item.offset + item.size\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight\n\n  return sizeOfVisitedRows + sizeOfUnvisitedItems\n}\nconst getEstimatedTotalWidth = (\n  { totalColumn }: Props,\n  { column, estimatedColumnWidth, lastVisitedColumnIndex }: GridCache\n) => {\n  let sizeOfVisitedColumns = 0\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex]\n    sizeOfVisitedColumns = item.offset + item.size\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth\n\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems\n}\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight,\n}\n\nconst getOffset = (\n  props: Props,\n  index: number,\n  alignment: Alignment,\n  scrollOffset: number,\n  cache: GridCache,\n  type: CacheItemType,\n  scrollBarWidth: number\n) => {\n  const [size, estimatedSizeAssociates] = [\n    type === 'row' ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type],\n  ] as [number, (props: Props, cache: GridCache) => number]\n  const item = getItemFromCache(props, index, cache, type)\n\n  const estimatedSize = estimatedSizeAssociates(props, cache)\n\n  const maxOffset = max(0, min(estimatedSize - size, item.offset))\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size)\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT\n    } else {\n      alignment = CENTERED_ALIGNMENT\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset\n    }\n    case END_ALIGNMENT: {\n      return minOffset\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2)\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset\n      } else if (minOffset > maxOffset) {\n        return minOffset\n      } else if (scrollOffset < minOffset) {\n        return minOffset\n      } else {\n        return maxOffset\n      }\n    }\n  }\n}\n\nconst DynamicSizeGrid = createGrid({\n  name: 'ElDynamicSizeGrid',\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'column')\n    return [item.size, item.offset]\n  },\n\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, 'row')\n    return [item.size, item.offset]\n  },\n\n  getColumnOffset: (\n    props,\n    columnIndex,\n    alignment,\n    scrollLeft,\n    cache,\n    scrollBarWidth\n  ) =>\n    getOffset(\n      props,\n      columnIndex,\n      alignment,\n      scrollLeft,\n      cache,\n      'column',\n      scrollBarWidth\n    ),\n\n  getRowOffset: (\n    props,\n    rowIndex,\n    alignment,\n    scrollTop,\n    cache,\n    scrollBarWidth: number\n  ) =>\n    getOffset(\n      props,\n      rowIndex,\n      alignment,\n      scrollTop,\n      cache,\n      'row',\n      scrollBarWidth\n    ),\n\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) =>\n    findItem(props, cache, scrollLeft, 'column'),\n\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, 'column')\n\n    const maxOffset = scrollLeft + (props.width as number)\n\n    let offset = item.offset + item.size\n    let stopIndex = startIndex\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, startIndex, cache, 'column').size\n    }\n    return stopIndex\n  },\n\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n\n  getRowStartIndexForOffset: (props, scrollTop, cache) =>\n    findItem(props, cache, scrollTop, 'row'),\n\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props\n    const item = getItemFromCache(props, startIndex, cache, 'row')\n    const maxOffset = scrollTop + (height as number)\n\n    let offset = item.size + item.offset\n    let stopIndex = startIndex\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++\n      offset += getItemFromCache(props, stopIndex, cache, 'row').size\n    }\n\n    return stopIndex\n  },\n  injectToInstance: (instance, cache) => {\n    const resetAfter = (\n      { columnIndex, rowIndex }: Indices,\n      forceUpdate?: boolean\n    ) => {\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate\n\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(\n          cache.value.lastVisitedColumnIndex,\n          columnIndex - 1\n        )\n      }\n\n      if (isNumber(rowIndex)) {\n        // console.log(rowIndex)\n        cache.value.lastVisitedRowIndex = Math.min(\n          cache.value.lastVisitedRowIndex,\n          rowIndex - 1\n        )\n      }\n\n      instance.exposed?.getItemStyleCache.value(-1, null, null)\n\n      if (forceUpdate) instance.proxy?.$forceUpdate()\n    }\n\n    const resetAfterColumnIndex = (\n      columnIndex: number,\n      forceUpdate: boolean\n    ) => {\n      resetAfter(\n        {\n          columnIndex,\n        },\n        forceUpdate\n      )\n    }\n\n    const resetAfterRowIndex = (rowIndex: number, forceUpdate: boolean) => {\n      resetAfter(\n        {\n          rowIndex,\n        },\n        forceUpdate\n      )\n    }\n\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex,\n      resetAfterRowIndex,\n      resetAfter,\n    })\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {},\n    } as GridCache\n\n    // TODO: expose methods.\n    return cache\n  },\n\n  clearCache: false,\n\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!isFunction(columnWidth)) {\n        throwError(\n          SCOPE,\n          `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `\n        )\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(\n          SCOPE,\n          `\n          \"rowHeight\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `\n        )\n      }\n    }\n  },\n})\n\nexport default DynamicSizeGrid\n\nexport type ResetAfterIndex = (idx: number, forceUpdate: boolean) => void\nexport type ResetAfterIndices = (indices: Indices, forceUpdate: boolean) => void\n\nexport type DynamicSizeGridInstance = GridInstance & {\n  resetAfterColumnIndex: ResetAfterIndex\n  resetAfterRowIndex: ResetAfterIndex\n  resetAfter: ResetAfterIndices\n}\n"]},"metadata":{},"sourceType":"module"}