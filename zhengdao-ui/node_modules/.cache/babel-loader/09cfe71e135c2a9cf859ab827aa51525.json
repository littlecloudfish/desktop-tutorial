{"ast":null,"code":"import _typeof from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _classCallCheck from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/little/Documents/music_web/startproj/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.create.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport '../../../../utils/index.mjs';\nimport Node from './node.mjs';\nimport { getNodeKey } from './util.mjs';\nimport { hasOwn } from '@vue/shared';\n\nvar TreeStore = /*#__PURE__*/function () {\n  function TreeStore(options) {\n    _classCallCheck(this, TreeStore);\n\n    this.currentNode = null;\n    this.currentNodeKey = null;\n\n    for (var option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option];\n      }\n    }\n\n    this.nodesMap = {};\n  }\n\n  _createClass(TreeStore, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      this.root = new Node({\n        data: this.data,\n        store: this\n      });\n      this.root.initialize();\n\n      if (this.lazy && this.load) {\n        var loadFn = this.load;\n        loadFn(this.root, function (data) {\n          _this.root.doCreateChildren(data);\n\n          _this._initDefaultCheckedNodes();\n        });\n      } else {\n        this._initDefaultCheckedNodes();\n      }\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(value) {\n      var filterNodeMethod = this.filterNodeMethod;\n      var lazy = this.lazy;\n\n      var traverse = function traverse(node) {\n        var childNodes = node.root ? node.root.childNodes : node.childNodes;\n        childNodes.forEach(function (child) {\n          child.visible = filterNodeMethod.call(child, value, child.data, child);\n          traverse(child);\n        });\n\n        if (!node.visible && childNodes.length) {\n          var allHidden = true;\n          allHidden = !childNodes.some(function (child) {\n            return child.visible;\n          });\n\n          if (node.root) {\n            ;\n            node.root.visible = allHidden === false;\n          } else {\n            ;\n            node.visible = allHidden === false;\n          }\n        }\n\n        if (!value) return;\n        if (node.visible && !node.isLeaf && !lazy) node.expand();\n      };\n\n      traverse(this);\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(newVal) {\n      var instanceChanged = newVal !== this.root.data;\n\n      if (instanceChanged) {\n        this.root.setData(newVal);\n\n        this._initDefaultCheckedNodes();\n      } else {\n        this.root.updateChildren();\n      }\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(data) {\n      if (data instanceof Node) return data;\n      var key = _typeof(data) !== \"object\" ? data : getNodeKey(this.key, data);\n      return this.nodesMap[key] || null;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(data, refData) {\n      var refNode = this.getNode(refData);\n      refNode.parent.insertBefore({\n        data: data\n      }, refNode);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(data, refData) {\n      var refNode = this.getNode(refData);\n      refNode.parent.insertAfter({\n        data: data\n      }, refNode);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(data) {\n      var node = this.getNode(data);\n\n      if (node && node.parent) {\n        if (node === this.currentNode) {\n          this.currentNode = null;\n        }\n\n        node.parent.removeChild(node);\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(data, parentData) {\n      var parentNode = parentData ? this.getNode(parentData) : this.root;\n\n      if (parentNode) {\n        parentNode.insertChild({\n          data: data\n        });\n      }\n    }\n  }, {\n    key: \"_initDefaultCheckedNodes\",\n    value: function _initDefaultCheckedNodes() {\n      var _this2 = this;\n\n      var defaultCheckedKeys = this.defaultCheckedKeys || [];\n      var nodesMap = this.nodesMap;\n      defaultCheckedKeys.forEach(function (checkedKey) {\n        var node = nodesMap[checkedKey];\n\n        if (node) {\n          node.setChecked(true, !_this2.checkStrictly);\n        }\n      });\n    }\n  }, {\n    key: \"_initDefaultCheckedNode\",\n    value: function _initDefaultCheckedNode(node) {\n      var defaultCheckedKeys = this.defaultCheckedKeys || [];\n\n      if (defaultCheckedKeys.includes(node.key)) {\n        node.setChecked(true, !this.checkStrictly);\n      }\n    }\n  }, {\n    key: \"setDefaultCheckedKey\",\n    value: function setDefaultCheckedKey(newVal) {\n      if (newVal !== this.defaultCheckedKeys) {\n        this.defaultCheckedKeys = newVal;\n\n        this._initDefaultCheckedNodes();\n      }\n    }\n  }, {\n    key: \"registerNode\",\n    value: function registerNode(node) {\n      var key = this.key;\n      if (!node || !node.data) return;\n\n      if (!key) {\n        this.nodesMap[node.id] = node;\n      } else {\n        var nodeKey = node.key;\n        if (nodeKey !== void 0) this.nodesMap[node.key] = node;\n      }\n    }\n  }, {\n    key: \"deregisterNode\",\n    value: function deregisterNode(node) {\n      var _this3 = this;\n\n      var key = this.key;\n      if (!key || !node || !node.data) return;\n      node.childNodes.forEach(function (child) {\n        _this3.deregisterNode(child);\n      });\n      delete this.nodesMap[node.key];\n    }\n  }, {\n    key: \"getCheckedNodes\",\n    value: function getCheckedNodes() {\n      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeHalfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var checkedNodes = [];\n\n      var traverse = function traverse(node) {\n        var childNodes = node.root ? node.root.childNodes : node.childNodes;\n        childNodes.forEach(function (child) {\n          if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {\n            checkedNodes.push(child.data);\n          }\n\n          traverse(child);\n        });\n      };\n\n      traverse(this);\n      return checkedNodes;\n    }\n  }, {\n    key: \"getCheckedKeys\",\n    value: function getCheckedKeys() {\n      var _this4 = this;\n\n      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.getCheckedNodes(leafOnly).map(function (data) {\n        return (data || {})[_this4.key];\n      });\n    }\n  }, {\n    key: \"getHalfCheckedNodes\",\n    value: function getHalfCheckedNodes() {\n      var nodes = [];\n\n      var traverse = function traverse(node) {\n        var childNodes = node.root ? node.root.childNodes : node.childNodes;\n        childNodes.forEach(function (child) {\n          if (child.indeterminate) {\n            nodes.push(child.data);\n          }\n\n          traverse(child);\n        });\n      };\n\n      traverse(this);\n      return nodes;\n    }\n  }, {\n    key: \"getHalfCheckedKeys\",\n    value: function getHalfCheckedKeys() {\n      var _this5 = this;\n\n      return this.getHalfCheckedNodes().map(function (data) {\n        return (data || {})[_this5.key];\n      });\n    }\n  }, {\n    key: \"_getAllNodes\",\n    value: function _getAllNodes() {\n      var allNodes = [];\n      var nodesMap = this.nodesMap;\n\n      for (var nodeKey in nodesMap) {\n        if (hasOwn(nodesMap, nodeKey)) {\n          allNodes.push(nodesMap[nodeKey]);\n        }\n      }\n\n      return allNodes;\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren(key, data) {\n      var node = this.nodesMap[key];\n      if (!node) return;\n      var childNodes = node.childNodes;\n\n      for (var i = childNodes.length - 1; i >= 0; i--) {\n        var child = childNodes[i];\n        this.remove(child.data);\n      }\n\n      for (var _i = 0, j = data.length; _i < j; _i++) {\n        var _child = data[_i];\n        this.append(_child, node.data);\n      }\n    }\n  }, {\n    key: \"_setCheckedKeys\",\n    value: function _setCheckedKeys(key) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var checkedKeys = arguments.length > 2 ? arguments[2] : undefined;\n\n      var allNodes = this._getAllNodes().sort(function (a, b) {\n        return b.level - a.level;\n      });\n\n      var cache = /* @__PURE__ */Object.create(null);\n      var keys = Object.keys(checkedKeys);\n      allNodes.forEach(function (node) {\n        return node.setChecked(false, false);\n      });\n\n      for (var i = 0, j = allNodes.length; i < j; i++) {\n        var node = allNodes[i];\n        var nodeKey = node.data[key].toString();\n        var checked = keys.includes(nodeKey);\n\n        if (!checked) {\n          if (node.checked && !cache[nodeKey]) {\n            node.setChecked(false, false);\n          }\n\n          continue;\n        }\n\n        var parent = node.parent;\n\n        while (parent && parent.level > 0) {\n          cache[parent.data[key]] = true;\n          parent = parent.parent;\n        }\n\n        if (node.isLeaf || this.checkStrictly) {\n          node.setChecked(true, false);\n          continue;\n        }\n\n        node.setChecked(true, true);\n\n        if (leafOnly) {\n          (function () {\n            node.setChecked(false, false);\n\n            var traverse = function traverse(node2) {\n              var childNodes = node2.childNodes;\n              childNodes.forEach(function (child) {\n                if (!child.isLeaf) {\n                  child.setChecked(false, false);\n                }\n\n                traverse(child);\n              });\n            };\n\n            traverse(node);\n          })();\n        }\n      }\n    }\n  }, {\n    key: \"setCheckedNodes\",\n    value: function setCheckedNodes(array) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var key = this.key;\n      var checkedKeys = {};\n      array.forEach(function (item) {\n        checkedKeys[(item || {})[key]] = true;\n      });\n\n      this._setCheckedKeys(key, leafOnly, checkedKeys);\n    }\n  }, {\n    key: \"setCheckedKeys\",\n    value: function setCheckedKeys(keys) {\n      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.defaultCheckedKeys = keys;\n      var key = this.key;\n      var checkedKeys = {};\n      keys.forEach(function (key2) {\n        checkedKeys[key2] = true;\n      });\n\n      this._setCheckedKeys(key, leafOnly, checkedKeys);\n    }\n  }, {\n    key: \"setDefaultExpandedKeys\",\n    value: function setDefaultExpandedKeys(keys) {\n      var _this6 = this;\n\n      keys = keys || [];\n      this.defaultExpandedKeys = keys;\n      keys.forEach(function (key) {\n        var node = _this6.getNode(key);\n\n        if (node) node.expand(null, _this6.autoExpandParent);\n      });\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(data, checked, deep) {\n      var node = this.getNode(data);\n\n      if (node) {\n        node.setChecked(!!checked, deep);\n      }\n    }\n  }, {\n    key: \"getCurrentNode\",\n    value: function getCurrentNode() {\n      return this.currentNode;\n    }\n  }, {\n    key: \"setCurrentNode\",\n    value: function setCurrentNode(currentNode) {\n      var prevCurrentNode = this.currentNode;\n\n      if (prevCurrentNode) {\n        prevCurrentNode.isCurrent = false;\n      }\n\n      this.currentNode = currentNode;\n      this.currentNode.isCurrent = true;\n    }\n  }, {\n    key: \"setUserCurrentNode\",\n    value: function setUserCurrentNode(node) {\n      var shouldAutoExpandParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = node[this.key];\n      var currNode = this.nodesMap[key];\n      this.setCurrentNode(currNode);\n\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true);\n      }\n    }\n  }, {\n    key: \"setCurrentNodeKey\",\n    value: function setCurrentNodeKey(key) {\n      var shouldAutoExpandParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (key === null || key === void 0) {\n        this.currentNode && (this.currentNode.isCurrent = false);\n        this.currentNode = null;\n        return;\n      }\n\n      var node = this.getNode(key);\n\n      if (node) {\n        this.setCurrentNode(node);\n\n        if (shouldAutoExpandParent && this.currentNode.level > 1) {\n          this.currentNode.parent.expand(null, true);\n        }\n      }\n    }\n  }]);\n\n  return TreeStore;\n}();\n\nexport { TreeStore as default };","map":{"version":3,"mappings":"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","names":["TreeStore","options","currentNode","currentNodeKey","option","hasOwn","nodesMap","root","Node","data","store","initialize","lazy","load","loadFn","doCreateChildren","_initDefaultCheckedNodes","value","filterNodeMethod","traverse","node","childNodes","forEach","child","visible","call","length","allHidden","some","isLeaf","expand","newVal","instanceChanged","setData","updateChildren","key","getNodeKey","refData","refNode","getNode","parent","insertBefore","insertAfter","removeChild","parentData","parentNode","insertChild","defaultCheckedKeys","checkedKey","setChecked","checkStrictly","includes","id","nodeKey","deregisterNode","leafOnly","includeHalfChecked","checkedNodes","checked","indeterminate","push","getCheckedNodes","map","nodes","getHalfCheckedNodes","allNodes","i","remove","j","append","checkedKeys","_getAllNodes","sort","a","b","level","cache","Object","create","keys","toString","node2","array","item","_setCheckedKeys","key2","defaultExpandedKeys","autoExpandParent","deep","prevCurrentNode","isCurrent","shouldAutoExpandParent","currNode","setCurrentNode"],"sources":["../../../../../../../packages/components/tree/src/model/tree-store.ts"],"sourcesContent":["// @ts-nocheck\nimport { hasOwn } from '@element-plus/utils'\nimport Node from './node'\nimport { getNodeKey } from './util'\n\nimport type {\n  FilterNodeMethodFunction,\n  FilterValue,\n  LoadFunction,\n  TreeData,\n  TreeKey,\n  TreeNodeData,\n  TreeOptionProps,\n  TreeStoreNodesMap,\n  TreeStoreOptions,\n} from '../tree.type'\n\nexport default class TreeStore {\n  currentNode: Node\n  currentNodeKey: TreeKey\n  nodesMap: TreeStoreNodesMap\n  root: Node\n  data: TreeData\n  lazy: boolean\n  load: LoadFunction\n  filterNodeMethod: FilterNodeMethodFunction\n  key: TreeKey\n  defaultCheckedKeys: TreeKey[]\n  checkStrictly: boolean\n  defaultExpandedKeys: TreeKey[]\n  autoExpandParent: boolean\n  defaultExpandAll: boolean\n  checkDescendants: boolean\n  props: TreeOptionProps\n\n  constructor(options: TreeStoreOptions) {\n    this.currentNode = null\n    this.currentNodeKey = null\n\n    for (const option in options) {\n      if (hasOwn(options, option)) {\n        this[option] = options[option]\n      }\n    }\n\n    this.nodesMap = {}\n  }\n\n  initialize() {\n    this.root = new Node({\n      data: this.data,\n      store: this,\n    })\n    this.root.initialize()\n\n    if (this.lazy && this.load) {\n      const loadFn = this.load\n      loadFn(this.root, (data) => {\n        this.root.doCreateChildren(data)\n        this._initDefaultCheckedNodes()\n      })\n    } else {\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  filter(value: FilterValue): void {\n    const filterNodeMethod = this.filterNodeMethod\n    const lazy = this.lazy\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        child.visible = filterNodeMethod.call(child, value, child.data, child)\n\n        traverse(child)\n      })\n\n      if (!(node as Node).visible && childNodes.length) {\n        let allHidden = true\n        allHidden = !childNodes.some((child) => child.visible)\n\n        if ((node as TreeStore).root) {\n          ;(node as TreeStore).root.visible = allHidden === false\n        } else {\n          ;(node as Node).visible = allHidden === false\n        }\n      }\n      if (!value) return\n\n      if ((node as Node).visible && !(node as Node).isLeaf && !lazy)\n        (node as Node).expand()\n    }\n\n    traverse(this)\n  }\n\n  setData(newVal: TreeData): void {\n    const instanceChanged = newVal !== this.root.data\n    if (instanceChanged) {\n      this.root.setData(newVal)\n      this._initDefaultCheckedNodes()\n    } else {\n      this.root.updateChildren()\n    }\n  }\n\n  getNode(data: TreeKey | TreeNodeData): Node {\n    if (data instanceof Node) return data\n    const key = typeof data !== 'object' ? data : getNodeKey(this.key, data)\n    return this.nodesMap[key] || null\n  }\n\n  insertBefore(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertBefore({ data }, refNode)\n  }\n\n  insertAfter(data: TreeNodeData, refData: TreeKey | TreeNodeData): void {\n    const refNode = this.getNode(refData)\n    refNode.parent.insertAfter({ data }, refNode)\n  }\n\n  remove(data: TreeNodeData | Node): void {\n    const node = this.getNode(data)\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null\n      }\n      node.parent.removeChild(node)\n    }\n  }\n\n  append(data: TreeNodeData, parentData: TreeNodeData | TreeKey | Node): void {\n    const parentNode = parentData ? this.getNode(parentData) : this.root\n\n    if (parentNode) {\n      parentNode.insertChild({ data })\n    }\n  }\n\n  _initDefaultCheckedNodes(): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n    const nodesMap = this.nodesMap\n\n    defaultCheckedKeys.forEach((checkedKey) => {\n      const node = nodesMap[checkedKey]\n\n      if (node) {\n        node.setChecked(true, !this.checkStrictly)\n      }\n    })\n  }\n\n  _initDefaultCheckedNode(node: Node): void {\n    const defaultCheckedKeys = this.defaultCheckedKeys || []\n\n    if (defaultCheckedKeys.includes(node.key)) {\n      node.setChecked(true, !this.checkStrictly)\n    }\n  }\n\n  setDefaultCheckedKey(newVal: TreeKey[]): void {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal\n      this._initDefaultCheckedNodes()\n    }\n  }\n\n  registerNode(node: Node): void {\n    const key = this.key\n    if (!node || !node.data) return\n\n    if (!key) {\n      this.nodesMap[node.id] = node\n    } else {\n      const nodeKey = node.key\n      if (nodeKey !== undefined) this.nodesMap[node.key] = node\n    }\n  }\n\n  deregisterNode(node: Node): void {\n    const key = this.key\n    if (!key || !node || !node.data) return\n\n    node.childNodes.forEach((child) => {\n      this.deregisterNode(child)\n    })\n\n    delete this.nodesMap[node.key]\n  }\n\n  getCheckedNodes(\n    leafOnly = false,\n    includeHalfChecked = false\n  ): TreeNodeData[] {\n    const checkedNodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (\n          (child.checked || (includeHalfChecked && child.indeterminate)) &&\n          (!leafOnly || (leafOnly && child.isLeaf))\n        ) {\n          checkedNodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return checkedNodes\n  }\n\n  getCheckedKeys(leafOnly = false): TreeKey[] {\n    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key])\n  }\n\n  getHalfCheckedNodes(): TreeNodeData[] {\n    const nodes: TreeNodeData[] = []\n    const traverse = function (node: TreeStore | Node) {\n      const childNodes = (node as TreeStore).root\n        ? (node as TreeStore).root.childNodes\n        : (node as Node).childNodes\n\n      childNodes.forEach((child) => {\n        if (child.indeterminate) {\n          nodes.push(child.data)\n        }\n\n        traverse(child)\n      })\n    }\n\n    traverse(this)\n\n    return nodes\n  }\n\n  getHalfCheckedKeys(): TreeKey[] {\n    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key])\n  }\n\n  _getAllNodes(): Node[] {\n    const allNodes: Node[] = []\n    const nodesMap = this.nodesMap\n    for (const nodeKey in nodesMap) {\n      if (hasOwn(nodesMap, nodeKey)) {\n        allNodes.push(nodesMap[nodeKey])\n      }\n    }\n\n    return allNodes\n  }\n\n  updateChildren(key: TreeKey, data: TreeData): void {\n    const node = this.nodesMap[key]\n    if (!node) return\n    const childNodes = node.childNodes\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      const child = childNodes[i]\n      this.remove(child.data)\n    }\n    for (let i = 0, j = data.length; i < j; i++) {\n      const child = data[i]\n      this.append(child, node.data)\n    }\n  }\n\n  _setCheckedKeys(\n    key: TreeKey,\n    leafOnly = false,\n    checkedKeys: { [key: string]: boolean }\n  ): void {\n    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level)\n    const cache = Object.create(null)\n    const keys = Object.keys(checkedKeys)\n    allNodes.forEach((node) => node.setChecked(false, false))\n    for (let i = 0, j = allNodes.length; i < j; i++) {\n      const node = allNodes[i]\n      const nodeKey = node.data[key].toString()\n      const checked = keys.includes(nodeKey)\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false)\n        }\n        continue\n      }\n\n      let parent = node.parent\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true\n        parent = parent.parent\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false)\n        continue\n      }\n      node.setChecked(true, true)\n\n      if (leafOnly) {\n        node.setChecked(false, false)\n        const traverse = function (node: Node): void {\n          const childNodes = node.childNodes\n          childNodes.forEach((child) => {\n            if (!child.isLeaf) {\n              child.setChecked(false, false)\n            }\n            traverse(child)\n          })\n        }\n        traverse(node)\n      }\n    }\n  }\n\n  setCheckedNodes(array: Node[], leafOnly = false): void {\n    const key = this.key\n    const checkedKeys = {}\n    array.forEach((item) => {\n      checkedKeys[(item || {})[key]] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setCheckedKeys(keys: TreeKey[], leafOnly = false): void {\n    this.defaultCheckedKeys = keys\n    const key = this.key\n    const checkedKeys = {}\n    keys.forEach((key) => {\n      checkedKeys[key] = true\n    })\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys)\n  }\n\n  setDefaultExpandedKeys(keys: TreeKey[]) {\n    keys = keys || []\n    this.defaultExpandedKeys = keys\n    keys.forEach((key) => {\n      const node = this.getNode(key)\n      if (node) node.expand(null, this.autoExpandParent)\n    })\n  }\n\n  setChecked(\n    data: TreeKey | TreeNodeData,\n    checked: boolean,\n    deep: boolean\n  ): void {\n    const node = this.getNode(data)\n\n    if (node) {\n      node.setChecked(!!checked, deep)\n    }\n  }\n\n  getCurrentNode(): Node {\n    return this.currentNode\n  }\n\n  setCurrentNode(currentNode: Node): void {\n    const prevCurrentNode = this.currentNode\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false\n    }\n    this.currentNode = currentNode\n    this.currentNode.isCurrent = true\n  }\n\n  setUserCurrentNode(node: Node, shouldAutoExpandParent = true): void {\n    const key = node[this.key]\n    const currNode = this.nodesMap[key]\n    this.setCurrentNode(currNode)\n    if (shouldAutoExpandParent && this.currentNode.level > 1) {\n      this.currentNode.parent.expand(null, true)\n    }\n  }\n\n  setCurrentNodeKey(key: TreeKey, shouldAutoExpandParent = true): void {\n    if (key === null || key === undefined) {\n      this.currentNode && (this.currentNode.isCurrent = false)\n      this.currentNode = null\n      return\n    }\n    const node = this.getNode(key)\n    if (node) {\n      this.setCurrentNode(node)\n      if (shouldAutoExpandParent && this.currentNode.level > 1) {\n        this.currentNode.parent.expand(null, true)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}