{"ast":null,"code":"import _objectSpread from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/little/Documents/music_web/backandfrontsep/zhengdao-ui/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.parse-int.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, h, resolveDynamicComponent } from 'vue';\nimport { isNumber, isClient } from '@vueuse/core';\nimport '../../../../utils/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { isRTL, getRTLOffsetType, getScrollDir } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { getScrollBarWidth } from '../../../../utils/dom/scroll.mjs';\nimport { hasOwn, isString } from '@vue/shared';\n\nvar createGrid = function createGrid(_ref) {\n  var name = _ref.name,\n      clearCache = _ref.clearCache,\n      getColumnPosition = _ref.getColumnPosition,\n      getColumnStartIndexForOffset = _ref.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref.getColumnStopIndexForStartIndex,\n      getEstimatedTotalHeight = _ref.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref.getEstimatedTotalWidth,\n      getColumnOffset = _ref.getColumnOffset,\n      getRowOffset = _ref.getRowOffset,\n      getRowPosition = _ref.getRowPosition,\n      getRowStartIndexForOffset = _ref.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref.getRowStopIndexForStartIndex,\n      initCache = _ref.initCache,\n      injectToInstance = _ref.injectToInstance,\n      validateProps = _ref.validateProps;\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n          expose = _ref2.expose,\n          slots = _ref2.slots;\n      var ns = useNamespace(\"vl\");\n      validateProps(props);\n      var instance = getCurrentInstance();\n      var cache = ref(initCache(props, instance));\n      injectToInstance == null ? void 0 : injectToInstance(instance, cache);\n      var windowRef = ref();\n      var hScrollbar = ref();\n      var vScrollbar = ref();\n      var innerRef = ref(null);\n      var states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      var getItemStyleCache = useCache();\n      var parsedHeight = computed(function () {\n        return Number.parseInt(\"\".concat(props.height), 10);\n      });\n      var parsedWidth = computed(function () {\n        return Number.parseInt(\"\".concat(props.width), 10);\n      });\n      var columnsToRender = computed(function () {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow,\n            columnCache = props.columnCache;\n\n        var _unref = unref(states),\n            isScrolling = _unref.isScrolling,\n            xAxisScrollDir = _unref.xAxisScrollDir,\n            scrollLeft = _unref.scrollLeft;\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        var startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        var stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        var cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        var cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var rowsToRender = computed(function () {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow,\n            rowCache = props.rowCache;\n\n        var _unref2 = unref(states),\n            isScrolling = _unref2.isScrolling,\n            yAxisScrollDir = _unref2.yAxisScrollDir,\n            scrollTop = _unref2.scrollTop;\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        var startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        var stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        var cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        var cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalHeight = computed(function () {\n        return getEstimatedTotalHeight(props, unref(cache));\n      });\n      var estimatedTotalWidth = computed(function () {\n        return getEstimatedTotalWidth(props, unref(cache));\n      });\n      var windowStyle = computed(function () {\n        var _a;\n\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      var innerStyle = computed(function () {\n        var width = \"\".concat(unref(estimatedTotalWidth), \"px\");\n        var height = \"\".concat(unref(estimatedTotalHeight), \"px\");\n        return {\n          height: height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: width\n        };\n      });\n\n      var emitEvents = function emitEvents() {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow;\n\n        if (totalColumn > 0 && totalRow > 0) {\n          var _unref3 = unref(columnsToRender),\n              _unref4 = _slicedToArray(_unref3, 4),\n              columnCacheStart = _unref4[0],\n              columnCacheEnd = _unref4[1],\n              columnVisibleStart = _unref4[2],\n              columnVisibleEnd = _unref4[3];\n\n          var _unref5 = unref(rowsToRender),\n              _unref6 = _slicedToArray(_unref5, 4),\n              rowCacheStart = _unref6[0],\n              rowCacheEnd = _unref6[1],\n              rowVisibleStart = _unref6[2],\n              rowVisibleEnd = _unref6[3];\n\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart: columnCacheStart,\n            columnCacheEnd: columnCacheEnd,\n            rowCacheStart: rowCacheStart,\n            rowCacheEnd: rowCacheEnd,\n            columnVisibleStart: columnVisibleStart,\n            columnVisibleEnd: columnVisibleEnd,\n            rowVisibleStart: rowVisibleStart,\n            rowVisibleEnd: rowVisibleEnd\n          });\n        }\n\n        var _unref7 = unref(states),\n            scrollLeft = _unref7.scrollLeft,\n            scrollTop = _unref7.scrollTop,\n            updateRequested = _unref7.updateRequested,\n            xAxisScrollDir = _unref7.xAxisScrollDir,\n            yAxisScrollDir = _unref7.yAxisScrollDir;\n\n        emit(SCROLL_EVT, {\n          xAxisScrollDir: xAxisScrollDir,\n          scrollLeft: scrollLeft,\n          yAxisScrollDir: yAxisScrollDir,\n          scrollTop: scrollTop,\n          updateRequested: updateRequested\n        });\n      };\n\n      var onScroll = function onScroll(e) {\n        var _e$currentTarget = e.currentTarget,\n            clientHeight = _e$currentTarget.clientHeight,\n            clientWidth = _e$currentTarget.clientWidth,\n            scrollHeight = _e$currentTarget.scrollHeight,\n            scrollLeft = _e$currentTarget.scrollLeft,\n            scrollTop = _e$currentTarget.scrollTop,\n            scrollWidth = _e$currentTarget.scrollWidth;\n\n        var _states = unref(states);\n\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n\n        var _scrollLeft = scrollLeft;\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(function () {\n          return resetIsScrolling();\n        });\n        onUpdated();\n        emitEvents();\n      };\n\n      var onVerticalScroll = function onVerticalScroll(distance, totalSteps) {\n        var height = unref(parsedHeight);\n        var offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n\n      var onHorizontalScroll = function onHorizontalScroll(distance, totalSteps) {\n        var width = unref(parsedWidth);\n        var offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n\n      var _useGridWheel = useGridWheel({\n        atXStartEdge: computed(function () {\n          return states.value.scrollLeft <= 0;\n        }),\n        atXEndEdge: computed(function () {\n          return states.value.scrollLeft >= estimatedTotalWidth.value;\n        }),\n        atYStartEdge: computed(function () {\n          return states.value.scrollTop <= 0;\n        }),\n        atYEndEdge: computed(function () {\n          return states.value.scrollTop >= estimatedTotalHeight.value;\n        })\n      }, function (x, y) {\n        var _a, _b, _c, _d;\n\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        var width = unref(parsedWidth);\n        var height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      }),\n          onWheel = _useGridWheel.onWheel;\n\n      var scrollTo = function scrollTo(_ref3) {\n        var _ref3$scrollLeft = _ref3.scrollLeft,\n            scrollLeft = _ref3$scrollLeft === void 0 ? states.value.scrollLeft : _ref3$scrollLeft,\n            _ref3$scrollTop = _ref3.scrollTop,\n            scrollTop = _ref3$scrollTop === void 0 ? states.value.scrollTop : _ref3$scrollTop;\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n\n        var _states = unref(states);\n\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          updateRequested: true\n        });\n        nextTick(function () {\n          return resetIsScrolling();\n        });\n        onUpdated();\n        emitEvents();\n      };\n\n      var scrollToItem = function scrollToItem() {\n        var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var columnIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var alignment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AUTO_ALIGNMENT;\n\n        var _states = unref(states);\n\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        var scrollBarWidth = getScrollBarWidth(ns.namespace.value);\n\n        var _cache = unref(cache);\n\n        var estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        var estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n\n      var getItemStyle = function getItemStyle(rowIndex, columnIndex) {\n        var columnWidth = props.columnWidth,\n            direction = props.direction,\n            rowHeight = props.rowHeight;\n        var itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        var key = \"\".concat(rowIndex, \",\").concat(columnIndex);\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          var _getColumnPosition = getColumnPosition(props, columnIndex, unref(cache)),\n              _getColumnPosition2 = _slicedToArray(_getColumnPosition, 2),\n              left = _getColumnPosition2[1];\n\n          var _cache = unref(cache);\n\n          var rtl = isRTL(direction);\n\n          var _getRowPosition = getRowPosition(props, rowIndex, _cache),\n              _getRowPosition2 = _slicedToArray(_getRowPosition, 2),\n              height = _getRowPosition2[0],\n              top = _getRowPosition2[1];\n\n          var _getColumnPosition3 = getColumnPosition(props, columnIndex, _cache),\n              _getColumnPosition4 = _slicedToArray(_getColumnPosition3, 1),\n              width = _getColumnPosition4[0];\n\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : \"\".concat(left, \"px\"),\n            right: rtl ? \"\".concat(left, \"px\") : void 0,\n            top: \"\".concat(top, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            width: \"\".concat(width, \"px\")\n          };\n          return itemStyleCache[key];\n        }\n      };\n\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      onMounted(function () {\n        if (!isClient) return;\n        var initScrollLeft = props.initScrollLeft,\n            initScrollTop = props.initScrollTop;\n        var windowElement = unref(windowRef);\n\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n\n        emitEvents();\n      });\n\n      var onUpdated = function onUpdated() {\n        var direction = props.direction;\n\n        var _unref8 = unref(states),\n            scrollLeft = _unref8.scrollLeft,\n            scrollTop = _unref8.scrollTop,\n            updateRequested = _unref8.updateRequested;\n\n        var windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n\n              default:\n                {\n                  var clientWidth = windowElement.clientWidth,\n                      scrollWidth = windowElement.scrollWidth;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      };\n\n      var _instance$proxy = instance.proxy,\n          resetAfterColumnIndex = _instance$proxy.resetAfterColumnIndex,\n          resetAfterRowIndex = _instance$proxy.resetAfterRowIndex,\n          resetAfter = _instance$proxy.resetAfter;\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        states: states,\n        resetAfterColumnIndex: resetAfterColumnIndex,\n        resetAfterRowIndex: resetAfterRowIndex,\n        resetAfter: resetAfter\n      });\n\n      var renderScrollbars = function renderScrollbars() {\n        var scrollbarAlwaysOn = props.scrollbarAlwaysOn,\n            scrollbarStartGap = props.scrollbarStartGap,\n            scrollbarEndGap = props.scrollbarEndGap,\n            totalColumn = props.totalColumn,\n            totalRow = props.totalRow;\n        var width = unref(parsedWidth);\n        var height = unref(parsedHeight);\n        var estimatedWidth = unref(estimatedTotalWidth);\n        var estimatedHeight = unref(estimatedTotalHeight);\n\n        var _unref9 = unref(states),\n            scrollLeft = _unref9.scrollLeft,\n            scrollTop = _unref9.scrollTop;\n\n        var horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          \"class\": ns.e(\"horizontal\"),\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        var verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          \"class\": ns.e(\"vertical\"),\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar: horizontalScrollbar,\n          verticalScrollbar: verticalScrollbar\n        };\n      };\n\n      var renderItems = function renderItems() {\n        var _a;\n\n        var _unref10 = unref(columnsToRender),\n            _unref11 = _slicedToArray(_unref10, 2),\n            columnStart = _unref11[0],\n            columnEnd = _unref11[1];\n\n        var _unref12 = unref(rowsToRender),\n            _unref13 = _slicedToArray(_unref12, 2),\n            rowStart = _unref13[0],\n            rowEnd = _unref13[1];\n\n        var data = props.data,\n            totalColumn = props.totalColumn,\n            totalRow = props.totalRow,\n            useIsScrolling = props.useIsScrolling,\n            itemKey = props.itemKey;\n        var children = [];\n\n        if (totalRow > 0 && totalColumn > 0) {\n          for (var row = rowStart; row <= rowEnd; row++) {\n            for (var column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots[\"default\"]) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data: data,\n                key: itemKey({\n                  columnIndex: column,\n                  data: data,\n                  rowIndex: row\n                }),\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n\n        return children;\n      };\n\n      var renderInner = function renderInner() {\n        var Inner = resolveDynamicComponent(props.innerElement);\n        var children = renderItems();\n        return [h(Inner, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }, !isString(Inner) ? {\n          \"default\": function _default() {\n            return children;\n          }\n        } : children)];\n      };\n\n      var renderWindow = function renderWindow() {\n        var Container = resolveDynamicComponent(props.containerElement);\n\n        var _renderScrollbars = renderScrollbars(),\n            horizontalScrollbar = _renderScrollbars.horizontalScrollbar,\n            verticalScrollbar = _renderScrollbars.verticalScrollbar;\n\n        var Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          \"class\": ns.e(\"wrapper\")\n        }, [h(Container, {\n          \"class\": props.className,\n          style: unref(windowStyle),\n          onScroll: onScroll,\n          onWheel: onWheel,\n          ref: windowRef\n        }, !isString(Container) ? {\n          \"default\": function _default() {\n            return Inner;\n          }\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n\n      return renderWindow;\n    }\n  });\n};\n\nexport { createGrid as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;AAmCK,IAACA,UAAU,GAAG,SAAbA,UAAa,OAgBb;EAAA,IAfJC,IAeI,QAfJA,IAeI;EAAA,IAdJC,UAcI,QAdJA,UAcI;EAAA,IAbJC,iBAaI,QAbJA,iBAaI;EAAA,IAZJC,4BAYI,QAZJA,4BAYI;EAAA,IAXJC,+BAWI,QAXJA,+BAWI;EAAA,IAVJC,uBAUI,QAVJA,uBAUI;EAAA,IATJC,sBASI,QATJA,sBASI;EAAA,IARJC,eAQI,QARJA,eAQI;EAAA,IAPJC,YAOI,QAPJA,YAOI;EAAA,IANJC,cAMI,QANJA,cAMI;EAAA,IALJC,yBAKI,QALJA,yBAKI;EAAA,IAJJC,4BAII,QAJJA,4BAII;EAAA,IAHJC,SAGI,QAHJA,SAGI;EAAA,IAFJC,gBAEI,QAFJA,gBAEI;EAAA,IADJC,aACI,QADJA,aACI;EACJ,OAAOC,eAAe,CAAC;IACrBf,IAAI,EAAEA,IAAI,IAAI,IAAR,GAAeA,IAAf,GAAsB,eADP;IAErBgB,KAAK,EAAEC,oBAFc;IAGrBC,KAAK,EAAE,CAACC,eAAD,EAAkBC,UAAlB,CAHc;IAIrBC,KAJqB,iBAIfL,KAJe,SAIiB;MAAA,IAAvBM,IAAuB,SAAvBA,IAAuB;MAAA,IAAjBC,MAAiB,SAAjBA,MAAiB;MAAA,IAATC,KAAS,SAATA,KAAS;MACpC,IAAMC,EAAE,GAAGC,YAAY,CAAC,IAAD,CAAvB;MACAZ,aAAa,CAACE,KAAD,CAAb;MACA,IAAMW,QAAQ,GAAGC,kBAAkB,EAAnC;MACA,IAAMC,KAAK,GAAGC,GAAG,CAAClB,SAAS,CAACI,KAAD,EAAQW,QAAR,CAAV,CAAjB;MACAd,gBAAgB,IAAI,IAApB,GAA2B,KAAK,CAAhC,GAAoCA,gBAAgB,CAACc,QAAD,EAAWE,KAAX,CAApD;MACA,IAAME,SAAS,GAAGD,GAAG,EAArB;MACA,IAAME,UAAU,GAAGF,GAAG,EAAtB;MACA,IAAMG,UAAU,GAAGH,GAAG,EAAtB;MACA,IAAMI,QAAQ,GAAGJ,GAAG,CAAC,IAAD,CAApB;MACA,IAAMK,MAAM,GAAGL,GAAG,CAAC;QACjBM,WAAW,EAAE,KADI;QAEjBC,UAAU,EAAEC,QAAQ,CAACtB,KAAK,CAACuB,cAAP,CAAR,GAAiCvB,KAAK,CAACuB,cAAvC,GAAwD,CAFnD;QAGjBC,SAAS,EAAEF,QAAQ,CAACtB,KAAK,CAACyB,aAAP,CAAR,GAAgCzB,KAAK,CAACyB,aAAtC,GAAsD,CAHhD;QAIjBC,eAAe,EAAE,KAJA;QAKjBC,cAAc,EAAEC,OALC;QAMjBC,cAAc,EAAED;MANC,CAAD,CAAlB;MAQA,IAAME,iBAAiB,GAAGC,QAAQ,EAAlC;MACA,IAAMC,YAAY,GAAGC,QAAQ,CAAC;QAAA,OAAMC,MAAM,CAACC,QAAP,WAAmBnC,KAAK,CAACoC,MAAzB,GAAmC,EAAnC,CAAN;MAAA,CAAD,CAA7B;MACA,IAAMC,WAAW,GAAGJ,QAAQ,CAAC;QAAA,OAAMC,MAAM,CAACC,QAAP,WAAmBnC,KAAK,CAACsC,KAAzB,GAAkC,EAAlC,CAAN;MAAA,CAAD,CAA5B;MACA,IAAMC,eAAe,GAAGN,QAAQ,CAAC,YAAM;QACrC,IAAQO,WAAR,GAA+CxC,KAA/C,CAAQwC,WAAR;QAAA,IAAqBC,QAArB,GAA+CzC,KAA/C,CAAqByC,QAArB;QAAA,IAA+BC,WAA/B,GAA+C1C,KAA/C,CAA+B0C,WAA/B;;QACA,aAAoDC,KAAK,CAACxB,MAAD,CAAzD;QAAA,IAAQC,WAAR,UAAQA,WAAR;QAAA,IAAqBO,cAArB,UAAqBA,cAArB;QAAA,IAAqCN,UAArC,UAAqCA,UAArC;;QACA,IAAImB,WAAW,KAAK,CAAhB,IAAqBC,QAAQ,KAAK,CAAtC,EAAyC;UACvC,OAAO,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAP;QACD;;QACD,IAAMG,UAAU,GAAGzD,4BAA4B,CAACa,KAAD,EAAQqB,UAAR,EAAoBsB,KAAK,CAAC9B,KAAD,CAAzB,CAA/C;QACA,IAAMgC,SAAS,GAAGzD,+BAA+B,CAACY,KAAD,EAAQ4C,UAAR,EAAoBvB,UAApB,EAAgCsB,KAAK,CAAC9B,KAAD,CAArC,CAAjD;QACA,IAAMiC,aAAa,GAAG,CAAC1B,WAAD,IAAgBO,cAAc,KAAKoB,QAAnC,GAA8CC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYP,WAAZ,CAA9C,GAAyE,CAA/F;QACA,IAAMQ,YAAY,GAAG,CAAC9B,WAAD,IAAgBO,cAAc,KAAKC,OAAnC,GAA6CoB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYP,WAAZ,CAA7C,GAAwE,CAA7F;QACA,OAAO,CACLM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYL,UAAU,GAAGE,aAAzB,CADK,EAELE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACG,GAAL,CAASX,WAAW,GAAG,CAAvB,EAA0BK,SAAS,GAAGK,YAAtC,CAAZ,CAFK,EAGLN,UAHK,EAILC,SAJK,CAAP;MAMD,CAhB+B,CAAhC;MAiBA,IAAMO,YAAY,GAAGnB,QAAQ,CAAC,YAAM;QAClC,IAAQO,WAAR,GAA4CxC,KAA5C,CAAQwC,WAAR;QAAA,IAAqBC,QAArB,GAA4CzC,KAA5C,CAAqByC,QAArB;QAAA,IAA+BY,QAA/B,GAA4CrD,KAA5C,CAA+BqD,QAA/B;;QACA,cAAmDV,KAAK,CAACxB,MAAD,CAAxD;QAAA,IAAQC,WAAR,WAAQA,WAAR;QAAA,IAAqBS,cAArB,WAAqBA,cAArB;QAAA,IAAqCL,SAArC,WAAqCA,SAArC;;QACA,IAAIgB,WAAW,KAAK,CAAhB,IAAqBC,QAAQ,KAAK,CAAtC,EAAyC;UACvC,OAAO,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAP;QACD;;QACD,IAAMG,UAAU,GAAGlD,yBAAyB,CAACM,KAAD,EAAQwB,SAAR,EAAmBmB,KAAK,CAAC9B,KAAD,CAAxB,CAA5C;QACA,IAAMgC,SAAS,GAAGlD,4BAA4B,CAACK,KAAD,EAAQ4C,UAAR,EAAoBpB,SAApB,EAA+BmB,KAAK,CAAC9B,KAAD,CAApC,CAA9C;QACA,IAAMiC,aAAa,GAAG,CAAC1B,WAAD,IAAgBS,cAAc,KAAKkB,QAAnC,GAA8CC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYI,QAAZ,CAA9C,GAAsE,CAA5F;QACA,IAAMH,YAAY,GAAG,CAAC9B,WAAD,IAAgBS,cAAc,KAAKD,OAAnC,GAA6CoB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYI,QAAZ,CAA7C,GAAqE,CAA1F;QACA,OAAO,CACLL,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYL,UAAU,GAAGE,aAAzB,CADK,EAELE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACG,GAAL,CAASV,QAAQ,GAAG,CAApB,EAAuBI,SAAS,GAAGK,YAAnC,CAAZ,CAFK,EAGLN,UAHK,EAILC,SAJK,CAAP;MAMD,CAhB4B,CAA7B;MAiBA,IAAMS,oBAAoB,GAAGrB,QAAQ,CAAC;QAAA,OAAM5C,uBAAuB,CAACW,KAAD,EAAQ2C,KAAK,CAAC9B,KAAD,CAAb,CAA7B;MAAA,CAAD,CAArC;MACA,IAAM0C,mBAAmB,GAAGtB,QAAQ,CAAC;QAAA,OAAM3C,sBAAsB,CAACU,KAAD,EAAQ2C,KAAK,CAAC9B,KAAD,CAAb,CAA5B;MAAA,CAAD,CAApC;MACA,IAAM2C,WAAW,GAAGvB,QAAQ,CAAC,YAAM;QACjC,IAAIwB,EAAJ;;QACA,OAAO,CACL;UACEC,QAAQ,EAAE,UADZ;UAEEC,QAAQ,EAAE,QAFZ;UAGEC,uBAAuB,EAAE,OAH3B;UAIEC,UAAU,EAAE;QAJd,CADK,EAOL;UACEC,SAAS,EAAE9D,KAAK,CAAC8D,SADnB;UAEE1B,MAAM,EAAEd,QAAQ,CAACtB,KAAK,CAACoC,MAAP,CAAR,aAA4BpC,KAAK,CAACoC,MAAlC,UAA+CpC,KAAK,CAACoC,MAF/D;UAGEE,KAAK,EAAEhB,QAAQ,CAACtB,KAAK,CAACsC,KAAP,CAAR,aAA2BtC,KAAK,CAACsC,KAAjC,UAA6CtC,KAAK,CAACsC;QAH5D,CAPK,EAYL,CAACmB,EAAE,GAAGzD,KAAK,CAAC+D,KAAZ,KAAsB,IAAtB,GAA6BN,EAA7B,GAAkC,EAZ7B,CAAP;MAcD,CAhB2B,CAA5B;MAiBA,IAAMO,UAAU,GAAG/B,QAAQ,CAAC,YAAM;QAChC,IAAMK,KAAK,aAAMK,KAAK,CAACY,mBAAD,CAAX,OAAX;QACA,IAAMnB,MAAM,aAAMO,KAAK,CAACW,oBAAD,CAAX,OAAZ;QACA,OAAO;UACLlB,MAAM,EAANA,MADK;UAEL6B,aAAa,EAAEtB,KAAK,CAACxB,MAAD,CAAL,CAAcC,WAAd,GAA4B,MAA5B,GAAqC,KAAK,CAFpD;UAGLkB,KAAK,EAALA;QAHK,CAAP;MAKD,CAR0B,CAA3B;;MASA,IAAM4B,UAAU,GAAG,SAAbA,UAAa,GAAM;QACvB,IAAQ1B,WAAR,GAAkCxC,KAAlC,CAAQwC,WAAR;QAAA,IAAqBC,QAArB,GAAkCzC,KAAlC,CAAqByC,QAArB;;QACA,IAAID,WAAW,GAAG,CAAd,IAAmBC,QAAQ,GAAG,CAAlC,EAAqC;UACnC,cAKIE,KAAK,CAACJ,eAAD,CALT;UAAA;UAAA,IACE4B,gBADF;UAAA,IAEEC,cAFF;UAAA,IAGEC,kBAHF;UAAA,IAIEC,gBAJF;;UAMA,cAAqE3B,KAAK,CAACS,YAAD,CAA1E;UAAA;UAAA,IAAOmB,aAAP;UAAA,IAAsBC,WAAtB;UAAA,IAAmCC,eAAnC;UAAA,IAAoDC,aAApD;;UACApE,IAAI,CAACH,eAAD,EAAkB;YACpBgE,gBAAgB,EAAhBA,gBADoB;YAEpBC,cAAc,EAAdA,cAFoB;YAGpBG,aAAa,EAAbA,aAHoB;YAIpBC,WAAW,EAAXA,WAJoB;YAKpBH,kBAAkB,EAAlBA,kBALoB;YAMpBC,gBAAgB,EAAhBA,gBANoB;YAOpBG,eAAe,EAAfA,eAPoB;YAQpBC,aAAa,EAAbA;UARoB,CAAlB,CAAJ;QAUD;;QACD,cAMI/B,KAAK,CAACxB,MAAD,CANT;QAAA,IACEE,UADF,WACEA,UADF;QAAA,IAEEG,SAFF,WAEEA,SAFF;QAAA,IAGEE,eAHF,WAGEA,eAHF;QAAA,IAIEC,cAJF,WAIEA,cAJF;QAAA,IAKEE,cALF,WAKEA,cALF;;QAOAvB,IAAI,CAACF,UAAD,EAAa;UACfuB,cAAc,EAAdA,cADe;UAEfN,UAAU,EAAVA,UAFe;UAGfQ,cAAc,EAAdA,cAHe;UAIfL,SAAS,EAATA,SAJe;UAKfE,eAAe,EAAfA;QALe,CAAb,CAAJ;MAOD,CAnCD;;MAoCA,IAAMiD,QAAQ,GAAG,SAAXA,QAAW,CAACC,CAAD,EAAO;QACtB,uBAOIA,CAAC,CAACC,aAPN;QAAA,IACEC,YADF,oBACEA,YADF;QAAA,IAEEC,WAFF,oBAEEA,WAFF;QAAA,IAGEC,YAHF,oBAGEA,YAHF;QAAA,IAIE3D,UAJF,oBAIEA,UAJF;QAAA,IAKEG,SALF,oBAKEA,SALF;QAAA,IAMEyD,WANF,oBAMEA,WANF;;QAQA,IAAMC,OAAO,GAAGvC,KAAK,CAACxB,MAAD,CAArB;;QACA,IAAI+D,OAAO,CAAC1D,SAAR,KAAsBA,SAAtB,IAAmC0D,OAAO,CAAC7D,UAAR,KAAuBA,UAA9D,EAA0E;UACxE;QACD;;QACD,IAAI8D,WAAW,GAAG9D,UAAlB;;QACA,IAAI+D,KAAK,CAACpF,KAAK,CAAC8D,SAAP,CAAT,EAA4B;UAC1B,QAAQuB,gBAAgB,EAAxB;YACE,KAAKC,cAAL;cACEH,WAAW,GAAG,CAAC9D,UAAf;cACA;;YACF,KAAKkE,mBAAL;cACEJ,WAAW,GAAGF,WAAW,GAAGF,WAAd,GAA4B1D,UAA1C;cACA;UANJ;QAQD;;QACDF,MAAM,CAACqE,KAAP,mCACKN,OADL;UAEE9D,WAAW,EAAE,IAFf;UAGEC,UAAU,EAAE8D,WAHd;UAIE3D,SAAS,EAAEwB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACG,GAAL,CAAS3B,SAAT,EAAoBwD,YAAY,GAAGF,YAAnC,CAAZ,CAJb;UAKEpD,eAAe,EAAE,IALnB;UAMEC,cAAc,EAAE8D,YAAY,CAACP,OAAO,CAAC7D,UAAT,EAAqB8D,WAArB,CAN9B;UAOEtD,cAAc,EAAE4D,YAAY,CAACP,OAAO,CAAC1D,SAAT,EAAoBA,SAApB;QAP9B;QASAkE,QAAQ,CAAC;UAAA,OAAMC,gBAAgB,EAAtB;QAAA,CAAD,CAAR;QACAC,SAAS;QACT1B,UAAU;MACX,CApCD;;MAqCA,IAAM2B,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,QAAD,EAAWC,UAAX,EAA0B;QACjD,IAAM3D,MAAM,GAAGO,KAAK,CAACX,YAAD,CAApB;QACA,IAAMgE,MAAM,GAAG,CAAC1C,oBAAoB,CAACkC,KAArB,GAA6BpD,MAA9B,IAAwC2D,UAAxC,GAAqDD,QAApE;QACAG,QAAQ,CAAC;UACPzE,SAAS,EAAEwB,IAAI,CAACG,GAAL,CAASG,oBAAoB,CAACkC,KAArB,GAA6BpD,MAAtC,EAA8C4D,MAA9C;QADJ,CAAD,CAAR;MAGD,CAND;;MAOA,IAAME,kBAAkB,GAAG,SAArBA,kBAAqB,CAACJ,QAAD,EAAWC,UAAX,EAA0B;QACnD,IAAMzD,KAAK,GAAGK,KAAK,CAACN,WAAD,CAAnB;QACA,IAAM2D,MAAM,GAAG,CAACzC,mBAAmB,CAACiC,KAApB,GAA4BlD,KAA7B,IAAsCyD,UAAtC,GAAmDD,QAAlE;QACAG,QAAQ,CAAC;UACP5E,UAAU,EAAE2B,IAAI,CAACG,GAAL,CAASI,mBAAmB,CAACiC,KAApB,GAA4BlD,KAArC,EAA4C0D,MAA5C;QADL,CAAD,CAAR;MAGD,CAND;;MAOA,oBAAoBG,YAAY,CAAC;QAC/BC,YAAY,EAAEnE,QAAQ,CAAC;UAAA,OAAMd,MAAM,CAACqE,KAAP,CAAanE,UAAb,IAA2B,CAAjC;QAAA,CAAD,CADS;QAE/BgF,UAAU,EAAEpE,QAAQ,CAAC;UAAA,OAAMd,MAAM,CAACqE,KAAP,CAAanE,UAAb,IAA2BkC,mBAAmB,CAACiC,KAArD;QAAA,CAAD,CAFW;QAG/Bc,YAAY,EAAErE,QAAQ,CAAC;UAAA,OAAMd,MAAM,CAACqE,KAAP,CAAahE,SAAb,IAA0B,CAAhC;QAAA,CAAD,CAHS;QAI/B+E,UAAU,EAAEtE,QAAQ,CAAC;UAAA,OAAMd,MAAM,CAACqE,KAAP,CAAahE,SAAb,IAA0B8B,oBAAoB,CAACkC,KAArD;QAAA,CAAD;MAJW,CAAD,EAK7B,UAACgB,CAAD,EAAIC,CAAJ,EAAU;QACX,IAAIhD,EAAJ,EAAQiD,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;QACA,CAACF,EAAE,GAAG,CAACjD,EAAE,GAAGzC,UAAU,CAACwE,KAAjB,KAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2C/B,EAAE,CAACoD,SAApD,KAAkE,IAAlE,GAAyE,KAAK,CAA9E,GAAkFH,EAAE,CAACI,IAAH,CAAQrD,EAAR,CAAlF;QACA,CAACmD,EAAE,GAAG,CAACD,EAAE,GAAG3F,UAAU,CAACwE,KAAjB,KAA2B,IAA3B,GAAkC,KAAK,CAAvC,GAA2CmB,EAAE,CAACE,SAApD,KAAkE,IAAlE,GAAyE,KAAK,CAA9E,GAAkFD,EAAE,CAACE,IAAH,CAAQH,EAAR,CAAlF;QACA,IAAMrE,KAAK,GAAGK,KAAK,CAACN,WAAD,CAAnB;QACA,IAAMD,MAAM,GAAGO,KAAK,CAACX,YAAD,CAApB;QACAiE,QAAQ,CAAC;UACP5E,UAAU,EAAE2B,IAAI,CAACG,GAAL,CAAShC,MAAM,CAACqE,KAAP,CAAanE,UAAb,GAA0BmF,CAAnC,EAAsCjD,mBAAmB,CAACiC,KAApB,GAA4BlD,KAAlE,CADL;UAEPd,SAAS,EAAEwB,IAAI,CAACG,GAAL,CAAShC,MAAM,CAACqE,KAAP,CAAahE,SAAb,GAAyBiF,CAAlC,EAAqCnD,oBAAoB,CAACkC,KAArB,GAA6BpD,MAAlE;QAFJ,CAAD,CAAR;MAID,CAf+B,CAAhC;MAAA,IAAQ2E,OAAR,iBAAQA,OAAR;;MAgBA,IAAMd,QAAQ,GAAG,SAAXA,QAAW,QAGX;QAAA,6BAFJ5E,UAEI;QAAA,IAFJA,UAEI,iCAFSF,MAAM,CAACqE,KAAP,CAAanE,UAEtB;QAAA,4BADJG,SACI;QAAA,IADJA,SACI,gCADQL,MAAM,CAACqE,KAAP,CAAahE,SACrB;QACJH,UAAU,GAAG2B,IAAI,CAACC,GAAL,CAAS5B,UAAT,EAAqB,CAArB,CAAb;QACAG,SAAS,GAAGwB,IAAI,CAACC,GAAL,CAASzB,SAAT,EAAoB,CAApB,CAAZ;;QACA,IAAM0D,OAAO,GAAGvC,KAAK,CAACxB,MAAD,CAArB;;QACA,IAAIK,SAAS,KAAK0D,OAAO,CAAC1D,SAAtB,IAAmCH,UAAU,KAAK6D,OAAO,CAAC7D,UAA9D,EAA0E;UACxE;QACD;;QACDF,MAAM,CAACqE,KAAP,mCACKN,OADL;UAEEvD,cAAc,EAAE8D,YAAY,CAACP,OAAO,CAAC7D,UAAT,EAAqBA,UAArB,CAF9B;UAGEQ,cAAc,EAAE4D,YAAY,CAACP,OAAO,CAAC1D,SAAT,EAAoBA,SAApB,CAH9B;UAIEH,UAAU,EAAVA,UAJF;UAKEG,SAAS,EAATA,SALF;UAMEE,eAAe,EAAE;QANnB;QAQAgE,QAAQ,CAAC;UAAA,OAAMC,gBAAgB,EAAtB;QAAA,CAAD,CAAR;QACAC,SAAS;QACT1B,UAAU;MACX,CArBD;;MAsBA,IAAM8C,YAAY,GAAG,SAAfA,YAAe,GAA6D;QAAA,IAA5DC,QAA4D,uEAAjD,CAAiD;QAAA,IAA9CC,SAA8C,uEAAlC,CAAkC;QAAA,IAA/BC,SAA+B,uEAAnBC,cAAmB;;QAChF,IAAMlC,OAAO,GAAGvC,KAAK,CAACxB,MAAD,CAArB;;QACA+F,SAAS,GAAGlE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACG,GAAL,CAAS+D,SAAT,EAAoBlH,KAAK,CAACwC,WAAN,GAAoB,CAAxC,CAAZ,CAAZ;QACAyE,QAAQ,GAAGjE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACG,GAAL,CAAS8D,QAAT,EAAmBjH,KAAK,CAACyC,QAAN,GAAiB,CAApC,CAAZ,CAAX;QACA,IAAM4E,cAAc,GAAGC,iBAAiB,CAAC7G,EAAE,CAAC8G,SAAH,CAAa/B,KAAd,CAAxC;;QACA,IAAMgC,MAAM,GAAG7E,KAAK,CAAC9B,KAAD,CAApB;;QACA,IAAM4G,eAAe,GAAGpI,uBAAuB,CAACW,KAAD,EAAQwH,MAAR,CAA/C;QACA,IAAME,cAAc,GAAGpI,sBAAsB,CAACU,KAAD,EAAQwH,MAAR,CAA7C;QACAvB,QAAQ,CAAC;UACP5E,UAAU,EAAE9B,eAAe,CAACS,KAAD,EAAQkH,SAAR,EAAmBC,SAAnB,EAA8BjC,OAAO,CAAC7D,UAAtC,EAAkDmG,MAAlD,EAA0DE,cAAc,GAAG1H,KAAK,CAACsC,KAAvB,GAA+B+E,cAA/B,GAAgD,CAA1G,CADpB;UAEP7F,SAAS,EAAEhC,YAAY,CAACQ,KAAD,EAAQiH,QAAR,EAAkBE,SAAlB,EAA6BjC,OAAO,CAAC1D,SAArC,EAAgDgG,MAAhD,EAAwDC,eAAe,GAAGzH,KAAK,CAACoC,MAAxB,GAAiCiF,cAAjC,GAAkD,CAA1G;QAFhB,CAAD,CAAR;MAID,CAZD;;MAaA,IAAMM,YAAY,GAAG,SAAfA,YAAe,CAACV,QAAD,EAAWW,WAAX,EAA2B;QAC9C,IAAQC,WAAR,GAA8C7H,KAA9C,CAAQ6H,WAAR;QAAA,IAAqB/D,SAArB,GAA8C9D,KAA9C,CAAqB8D,SAArB;QAAA,IAAgCgE,SAAhC,GAA8C9H,KAA9C,CAAgC8H,SAAhC;QACA,IAAMC,cAAc,GAAGjG,iBAAiB,CAAC0D,KAAlB,CAAwBvG,UAAU,IAAI4I,WAAtC,EAAmD5I,UAAU,IAAI6I,SAAjE,EAA4E7I,UAAU,IAAI6E,SAA1F,CAAvB;QACA,IAAMkE,GAAG,aAAMf,QAAN,cAAkBW,WAAlB,CAAT;;QACA,IAAIK,MAAM,CAACF,cAAD,EAAiBC,GAAjB,CAAV,EAAiC;UAC/B,OAAOD,cAAc,CAACC,GAAD,CAArB;QACD,CAFD,MAEO;UACL,yBAAiB9I,iBAAiB,CAACc,KAAD,EAAQ4H,WAAR,EAAqBjF,KAAK,CAAC9B,KAAD,CAA1B,CAAlC;UAAA;UAAA,IAASqH,IAAT;;UACA,IAAMV,MAAM,GAAG7E,KAAK,CAAC9B,KAAD,CAApB;;UACA,IAAMsH,GAAG,GAAG/C,KAAK,CAACtB,SAAD,CAAjB;;UACA,sBAAsBrE,cAAc,CAACO,KAAD,EAAQiH,QAAR,EAAkBO,MAAlB,CAApC;UAAA;UAAA,IAAOpF,MAAP;UAAA,IAAegG,GAAf;;UACA,0BAAgBlJ,iBAAiB,CAACc,KAAD,EAAQ4H,WAAR,EAAqBJ,MAArB,CAAjC;UAAA;UAAA,IAAOlF,KAAP;;UACAyF,cAAc,CAACC,GAAD,CAAd,GAAsB;YACpBtE,QAAQ,EAAE,UADU;YAEpBwE,IAAI,EAAEC,GAAG,GAAG,KAAK,CAAR,aAAeD,IAAf,OAFW;YAGpBG,KAAK,EAAEF,GAAG,aAAMD,IAAN,UAAiB,KAAK,CAHZ;YAIpBE,GAAG,YAAKA,GAAL,OAJiB;YAKpBhG,MAAM,YAAKA,MAAL,OALc;YAMpBE,KAAK,YAAKA,KAAL;UANe,CAAtB;UAQA,OAAOyF,cAAc,CAACC,GAAD,CAArB;QACD;MACF,CAtBD;;MAuBA,IAAMrC,gBAAgB,GAAG,SAAnBA,gBAAmB,GAAM;QAC7BxE,MAAM,CAACqE,KAAP,CAAapE,WAAb,GAA2B,KAA3B;QACAsE,QAAQ,CAAC,YAAM;UACb5D,iBAAiB,CAAC0D,KAAlB,CAAwB,CAAC,CAAzB,EAA4B,IAA5B,EAAkC,IAAlC;QACD,CAFO,CAAR;MAGD,CALD;;MAMA8C,SAAS,CAAC,YAAM;QACd,IAAI,CAACC,QAAL,EACE;QACF,IAAQhH,cAAR,GAA0CvB,KAA1C,CAAQuB,cAAR;QAAA,IAAwBE,aAAxB,GAA0CzB,KAA1C,CAAwByB,aAAxB;QACA,IAAM+G,aAAa,GAAG7F,KAAK,CAAC5B,SAAD,CAA3B;;QACA,IAAIyH,aAAJ,EAAmB;UACjB,IAAIlH,QAAQ,CAACC,cAAD,CAAZ,EAA8B;YAC5BiH,aAAa,CAACnH,UAAd,GAA2BE,cAA3B;UACD;;UACD,IAAID,QAAQ,CAACG,aAAD,CAAZ,EAA6B;YAC3B+G,aAAa,CAAChH,SAAd,GAA0BC,aAA1B;UACD;QACF;;QACDyC,UAAU;MACX,CAdQ,CAAT;;MAeA,IAAM0B,SAAS,GAAG,SAAZA,SAAY,GAAM;QACtB,IAAQ9B,SAAR,GAAsB9D,KAAtB,CAAQ8D,SAAR;;QACA,cAAmDnB,KAAK,CAACxB,MAAD,CAAxD;QAAA,IAAQE,UAAR,WAAQA,UAAR;QAAA,IAAoBG,SAApB,WAAoBA,SAApB;QAAA,IAA+BE,eAA/B,WAA+BA,eAA/B;;QACA,IAAM8G,aAAa,GAAG7F,KAAK,CAAC5B,SAAD,CAA3B;;QACA,IAAIW,eAAe,IAAI8G,aAAvB,EAAsC;UACpC,IAAI1E,SAAS,KAAK2E,GAAlB,EAAuB;YACrB,QAAQpD,gBAAgB,EAAxB;cACE,KAAKC,cAAL;gBAAqB;kBACnBkD,aAAa,CAACnH,UAAd,GAA2B,CAACA,UAA5B;kBACA;gBACD;;cACD,KAAKqH,kBAAL;gBAAyB;kBACvBF,aAAa,CAACnH,UAAd,GAA2BA,UAA3B;kBACA;gBACD;;cACD;gBAAS;kBACP,IAAQ0D,WAAR,GAAqCyD,aAArC,CAAQzD,WAAR;kBAAA,IAAqBE,WAArB,GAAqCuD,aAArC,CAAqBvD,WAArB;kBACAuD,aAAa,CAACnH,UAAd,GAA2B4D,WAAW,GAAGF,WAAd,GAA4B1D,UAAvD;kBACA;gBACD;YAbH;UAeD,CAhBD,MAgBO;YACLmH,aAAa,CAACnH,UAAd,GAA2B2B,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY5B,UAAZ,CAA3B;UACD;;UACDmH,aAAa,CAAChH,SAAd,GAA0BwB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYzB,SAAZ,CAA1B;QACD;MACF,CA1BD;;MA2BA,sBAAkEb,QAAQ,CAACgI,KAA3E;MAAA,IAAQC,qBAAR,mBAAQA,qBAAR;MAAA,IAA+BC,kBAA/B,mBAA+BA,kBAA/B;MAAA,IAAmDC,UAAnD,mBAAmDA,UAAnD;MACAvI,MAAM,CAAC;QACLQ,SAAS,EAATA,SADK;QAELG,QAAQ,EAARA,QAFK;QAGLY,iBAAiB,EAAjBA,iBAHK;QAILmE,QAAQ,EAARA,QAJK;QAKLe,YAAY,EAAZA,YALK;QAML7F,MAAM,EAANA,MANK;QAOLyH,qBAAqB,EAArBA,qBAPK;QAQLC,kBAAkB,EAAlBA,kBARK;QASLC,UAAU,EAAVA;MATK,CAAD,CAAN;;MAWA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,GAAM;QAC7B,IACEC,iBADF,GAMIhJ,KANJ,CACEgJ,iBADF;QAAA,IAEEC,iBAFF,GAMIjJ,KANJ,CAEEiJ,iBAFF;QAAA,IAGEC,eAHF,GAMIlJ,KANJ,CAGEkJ,eAHF;QAAA,IAIE1G,WAJF,GAMIxC,KANJ,CAIEwC,WAJF;QAAA,IAKEC,QALF,GAMIzC,KANJ,CAKEyC,QALF;QAOA,IAAMH,KAAK,GAAGK,KAAK,CAACN,WAAD,CAAnB;QACA,IAAMD,MAAM,GAAGO,KAAK,CAACX,YAAD,CAApB;QACA,IAAM0F,cAAc,GAAG/E,KAAK,CAACY,mBAAD,CAA5B;QACA,IAAMkE,eAAe,GAAG9E,KAAK,CAACW,oBAAD,CAA7B;;QACA,cAAkCX,KAAK,CAACxB,MAAD,CAAvC;QAAA,IAAQE,UAAR,WAAQA,UAAR;QAAA,IAAoBG,SAApB,WAAoBA,SAApB;;QACA,IAAM2H,mBAAmB,GAAGC,CAAC,CAACC,SAAD,EAAY;UACvCvI,GAAG,EAAEE,UADkC;UAEvCsI,QAAQ,EAAEN,iBAF6B;UAGvCO,QAAQ,EAAEN,iBAH6B;UAIvCO,MAAM,EAAEN,eAJ+B;UAKvC,SAAOzI,EAAE,CAACmE,CAAH,CAAK,YAAL,CALgC;UAMvC6E,UAAU,EAAEnH,KAN2B;UAOvCoH,MAAM,EAAE,YAP+B;UAQvC/E,QAAQ,EAAEuB,kBAR6B;UASvCyD,KAAK,EAAErH,KAAK,GAAG,GAAR,GAAcoF,cATkB;UAUvCkC,UAAU,EAAEvI,UAAU,IAAIqG,cAAc,GAAGpF,KAArB,CAViB;UAWvCuH,KAAK,EAAEpH,QAXgC;UAYvCqH,OAAO,EAAE;QAZ8B,CAAZ,CAA7B;QAcA,IAAMC,iBAAiB,GAAGX,CAAC,CAACC,SAAD,EAAY;UACrCvI,GAAG,EAAEG,UADgC;UAErCqI,QAAQ,EAAEN,iBAF2B;UAGrCO,QAAQ,EAAEN,iBAH2B;UAIrCO,MAAM,EAAEN,eAJ6B;UAKrC,SAAOzI,EAAE,CAACmE,CAAH,CAAK,UAAL,CAL8B;UAMrC6E,UAAU,EAAErH,MANyB;UAOrCsH,MAAM,EAAE,UAP6B;UAQrC/E,QAAQ,EAAEkB,gBAR2B;UASrC8D,KAAK,EAAEvH,MAAM,GAAG,GAAT,GAAeqF,eATe;UAUrCmC,UAAU,EAAEpI,SAAS,IAAIiG,eAAe,GAAGrF,MAAtB,CAVgB;UAWrCyH,KAAK,EAAErH,WAX8B;UAYrCsH,OAAO,EAAE;QAZ4B,CAAZ,CAA3B;QAcA,OAAO;UACLX,mBAAmB,EAAnBA,mBADK;UAELY,iBAAiB,EAAjBA;QAFK,CAAP;MAID,CA7CD;;MA8CA,IAAMC,WAAW,GAAG,SAAdA,WAAc,GAAM;QACxB,IAAIvG,EAAJ;;QACA,eAAiCd,KAAK,CAACJ,eAAD,CAAtC;QAAA;QAAA,IAAO0H,WAAP;QAAA,IAAoBC,SAApB;;QACA,eAA2BvH,KAAK,CAACS,YAAD,CAAhC;QAAA;QAAA,IAAO+G,QAAP;QAAA,IAAiBC,MAAjB;;QACA,IAAQC,IAAR,GAAiErK,KAAjE,CAAQqK,IAAR;QAAA,IAAc7H,WAAd,GAAiExC,KAAjE,CAAcwC,WAAd;QAAA,IAA2BC,QAA3B,GAAiEzC,KAAjE,CAA2ByC,QAA3B;QAAA,IAAqC6H,cAArC,GAAiEtK,KAAjE,CAAqCsK,cAArC;QAAA,IAAqDC,OAArD,GAAiEvK,KAAjE,CAAqDuK,OAArD;QACA,IAAMC,QAAQ,GAAG,EAAjB;;QACA,IAAI/H,QAAQ,GAAG,CAAX,IAAgBD,WAAW,GAAG,CAAlC,EAAqC;UACnC,KAAK,IAAIiI,GAAG,GAAGN,QAAf,EAAyBM,GAAG,IAAIL,MAAhC,EAAwCK,GAAG,EAA3C,EAA+C;YAC7C,KAAK,IAAIC,MAAM,GAAGT,WAAlB,EAA+BS,MAAM,IAAIR,SAAzC,EAAoDQ,MAAM,EAA1D,EAA8D;cAC5DF,QAAQ,CAACG,IAAT,CAAc,CAAClH,EAAE,GAAGjD,KAAK,WAAX,KAAwB,IAAxB,GAA+B,KAAK,CAApC,GAAwCiD,EAAE,CAACqD,IAAH,CAAQtG,KAAR,EAAe;gBACnEoH,WAAW,EAAE8C,MADsD;gBAEnEL,IAAI,EAAJA,IAFmE;gBAGnErC,GAAG,EAAEuC,OAAO,CAAC;kBAAE3C,WAAW,EAAE8C,MAAf;kBAAuBL,IAAI,EAAJA,IAAvB;kBAA6BpD,QAAQ,EAAEwD;gBAAvC,CAAD,CAHuD;gBAInErJ,WAAW,EAAEkJ,cAAc,GAAG3H,KAAK,CAACxB,MAAD,CAAL,CAAcC,WAAjB,GAA+B,KAAK,CAJI;gBAKnE2C,KAAK,EAAE4D,YAAY,CAAC8C,GAAD,EAAMC,MAAN,CALgD;gBAMnEzD,QAAQ,EAAEwD;cANyD,CAAf,CAAtD;YAQD;UACF;QACF;;QACD,OAAOD,QAAP;MACD,CArBD;;MAsBA,IAAMI,WAAW,GAAG,SAAdA,WAAc,GAAM;QACxB,IAAMC,KAAK,GAAGC,uBAAuB,CAAC9K,KAAK,CAAC+K,YAAP,CAArC;QACA,IAAMP,QAAQ,GAAGR,WAAW,EAA5B;QACA,OAAO,CACLZ,CAAC,CAACyB,KAAD,EAAQ;UACP9G,KAAK,EAAEpB,KAAK,CAACqB,UAAD,CADL;UAEPlD,GAAG,EAAEI;QAFE,CAAR,EAGE,CAAC8J,QAAQ,CAACH,KAAD,CAAT,GAAmB;UACpB,WAAS;YAAA,OAAML,QAAN;UAAA;QADW,CAAnB,GAECA,QALH,CADI,CAAP;MAQD,CAXD;;MAYA,IAAMS,YAAY,GAAG,SAAfA,YAAe,GAAM;QACzB,IAAMC,SAAS,GAAGJ,uBAAuB,CAAC9K,KAAK,CAACmL,gBAAP,CAAzC;;QACA,wBAAmDpC,gBAAgB,EAAnE;QAAA,IAAQI,mBAAR,qBAAQA,mBAAR;QAAA,IAA6BY,iBAA7B,qBAA6BA,iBAA7B;;QACA,IAAMc,KAAK,GAAGD,WAAW,EAAzB;QACA,OAAOxB,CAAC,CAAC,KAAD,EAAQ;UACdpB,GAAG,EAAE,CADS;UAEd,SAAOvH,EAAE,CAACmE,CAAH,CAAK,SAAL;QAFO,CAAR,EAGL,CACDwE,CAAC,CAAC8B,SAAD,EAAY;UACX,SAAOlL,KAAK,CAACoL,SADF;UAEXrH,KAAK,EAAEpB,KAAK,CAACa,WAAD,CAFD;UAGXmB,QAAQ,EAARA,QAHW;UAIXoC,OAAO,EAAPA,OAJW;UAKXjG,GAAG,EAAEC;QALM,CAAZ,EAME,CAACiK,QAAQ,CAACE,SAAD,CAAT,GAAuB;UAAE,WAAS;YAAA,OAAML,KAAN;UAAA;QAAX,CAAvB,GAAkDA,KANpD,CADA,EAQD1B,mBARC,EASDY,iBATC,CAHK,CAAR;MAcD,CAlBD;;MAmBA,OAAOkB,YAAP;IACD;EAxZoB,CAAD,CAAtB;AA0ZF,CA3aK","names":["createGrid","name","clearCache","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","injectToInstance","validateProps","defineComponent","props","virtualizedGridProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","slots","ns","useNamespace","instance","getCurrentInstance","cache","ref","windowRef","hScrollbar","vScrollbar","innerRef","states","isScrolling","scrollLeft","isNumber","initScrollLeft","scrollTop","initScrollTop","updateRequested","xAxisScrollDir","FORWARD","yAxisScrollDir","getItemStyleCache","useCache","parsedHeight","computed","Number","parseInt","height","parsedWidth","width","columnsToRender","totalColumn","totalRow","columnCache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","min","rowsToRender","rowCache","estimatedTotalHeight","estimatedTotalWidth","windowStyle","_a","position","overflow","WebkitOverflowScrolling","willChange","direction","style","innerStyle","pointerEvents","emitEvents","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","onScroll","e","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","_states","_scrollLeft","isRTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","value","getScrollDir","nextTick","resetIsScrolling","onUpdated","onVerticalScroll","distance","totalSteps","offset","scrollTo","onHorizontalScroll","useGridWheel","atXStartEdge","atXEndEdge","atYStartEdge","atYEndEdge","x","y","_b","_c","_d","onMouseUp","call","onWheel","scrollToItem","rowIndex","columnIdx","alignment","AUTO_ALIGNMENT","scrollBarWidth","getScrollBarWidth","namespace","_cache","estimatedHeight","estimatedWidth","getItemStyle","columnIndex","columnWidth","rowHeight","itemStyleCache","key","hasOwn","left","rtl","top","right","onMounted","isClient","windowElement","RTL","RTL_OFFSET_POS_ASC","proxy","resetAfterColumnIndex","resetAfterRowIndex","resetAfter","renderScrollbars","scrollbarAlwaysOn","scrollbarStartGap","scrollbarEndGap","horizontalScrollbar","h","Scrollbar","alwaysOn","startGap","endGap","clientSize","layout","ratio","scrollFrom","total","visible","verticalScrollbar","renderItems","columnStart","columnEnd","rowStart","rowEnd","data","useIsScrolling","itemKey","children","row","column","push","renderInner","Inner","resolveDynamicComponent","innerElement","isString","renderWindow","Container","containerElement","className"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-grid.ts"],"sourcesContent":["// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  h,\n  nextTick,\n  onMounted,\n  ref,\n  resolveDynamicComponent,\n  unref,\n} from 'vue'\nimport { isClient } from '@vueuse/core'\nimport {\n  getScrollBarWidth,\n  hasOwn,\n  isNumber,\n  isString,\n} from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport Scrollbar from '../components/scrollbar'\nimport { useGridWheel } from '../hooks/use-grid-wheel'\nimport { useCache } from '../hooks/use-cache'\nimport { virtualizedGridProps } from '../props'\nimport { getRTLOffsetType, getScrollDir, isRTL } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  ITEM_RENDER_EVT,\n  RTL,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_ASC,\n  RTL_OFFSET_POS_DESC,\n  SCROLL_EVT,\n} from '../defaults'\nimport type {\n  CSSProperties,\n  Ref,\n  StyleValue,\n  UnwrapRef,\n  VNode,\n  VNodeChild,\n} from 'vue'\nimport type {\n  Alignment,\n  GridConstructorProps,\n  GridScrollOptions,\n  ScrollbarExpose,\n} from '../types'\nimport type { VirtualizedGridProps } from '../props'\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n\n  initCache,\n  injectToInstance,\n  validateProps,\n}: GridConstructorProps<VirtualizedGridProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      const ns = useNamespace('vl')\n\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const cache = ref(initCache(props, instance))\n      injectToInstance?.(instance, cache)\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const hScrollbar = ref<ScrollbarExpose>()\n      const vScrollbar = ref<ScrollbarExpose>()\n      // innerRef is the actual container element which contains all the elements\n      const innerRef = ref(null)\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD,\n      })\n\n      const getItemStyleCache = useCache()\n\n      // computed\n      const parsedHeight = computed(() =>\n        Number.parseInt(`${props.height}`, 10)\n      )\n      const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10))\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getColumnStartIndexForOffset(\n          props,\n          scrollLeft,\n          unref(cache)\n        )\n        const stopIndex = getColumnStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollLeft,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || xAxisScrollDir === BACKWARD\n            ? Math.max(1, columnCache)\n            : 1\n        const cacheForward =\n          !isScrolling || xAxisScrollDir === FORWARD\n            ? Math.max(1, columnCache)\n            : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getRowStartIndexForOffset(\n          props,\n          scrollTop,\n          unref(cache)\n        )\n        const stopIndex = getRowStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollTop,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || yAxisScrollDir === BACKWARD\n            ? Math.max(1, rowCache)\n            : 1\n        const cacheForward =\n          !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalHeight = computed(() =>\n        getEstimatedTotalHeight(props, unref(cache))\n      )\n      const estimatedTotalWidth = computed(() =>\n        getEstimatedTotalWidth(props, unref(cache))\n      )\n\n      const windowStyle = computed<StyleValue>(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style ?? {},\n      ])\n\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`\n        const height = `${unref(estimatedTotalHeight)}px`\n\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width,\n        }\n      })\n\n      // methods\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props\n\n        if (totalColumn! > 0 && totalRow! > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n          ] = unref(columnsToRender)\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] =\n            unref(rowsToRender)\n          // emit the render item event with\n          // [xAxisInvisibleStart, xAxisInvisibleEnd, xAxisVisibleStart, xAxisVisibleEnd]\n          // [yAxisInvisibleStart, yAxisInvisibleEnd, yAxisVisibleStart, yAxisVisibleEnd]\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd,\n          })\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir,\n        } = unref(states)\n        emit(SCROLL_EVT, {\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested,\n        })\n      }\n\n      const onScroll = (e: Event) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth,\n        } = e.currentTarget as HTMLElement\n\n        const _states = unref(states)\n\n        if (\n          _states.scrollTop === scrollTop &&\n          _states.scrollLeft === scrollLeft\n        ) {\n          return\n        }\n\n        let _scrollLeft = scrollLeft\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft\n              break\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft\n              break\n          }\n        }\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(\n            0,\n            Math.min(scrollTop, scrollHeight - clientHeight)\n          ),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n        }\n\n        nextTick(() => resetIsScrolling())\n\n        onUpdated()\n        emitEvents()\n      }\n\n      const onVerticalScroll = (distance: number, totalSteps: number) => {\n        const height = unref(parsedHeight)\n        const offset =\n          ((estimatedTotalHeight.value - height) / totalSteps) * distance\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset),\n        })\n      }\n\n      const onHorizontalScroll = (distance: number, totalSteps: number) => {\n        const width = unref(parsedWidth)\n        const offset =\n          ((estimatedTotalWidth.value - width) / totalSteps) * distance\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset),\n        })\n      }\n\n      const { onWheel } = useGridWheel(\n        {\n          atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n          atXEndEdge: computed(\n            () => states.value.scrollLeft >= estimatedTotalWidth.value\n          ),\n          atYStartEdge: computed(() => states.value.scrollTop <= 0),\n          atYEndEdge: computed(\n            () => states.value.scrollTop >= estimatedTotalHeight.value\n          ),\n        },\n        (x: number, y: number) => {\n          hScrollbar.value?.onMouseUp?.()\n          hScrollbar.value?.onMouseUp?.()\n          const width = unref(parsedWidth)\n          const height = unref(parsedHeight)\n          scrollTo({\n            scrollLeft: Math.min(\n              states.value.scrollLeft + x,\n              estimatedTotalWidth.value - width\n            ),\n            scrollTop: Math.min(\n              states.value.scrollTop + y,\n              estimatedTotalHeight.value - height\n            ),\n          })\n        }\n      )\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop,\n      }: GridScrollOptions) => {\n        scrollLeft = Math.max(scrollLeft, 0)\n        scrollTop = Math.max(scrollTop, 0)\n        const _states = unref(states)\n        if (\n          scrollTop === _states.scrollTop &&\n          scrollLeft === _states.scrollLeft\n        ) {\n          return\n        }\n\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true,\n        }\n\n        nextTick(() => resetIsScrolling())\n\n        onUpdated()\n        emitEvents()\n      }\n\n      const scrollToItem = (\n        rowIndex = 0,\n        columnIdx = 0,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const _states = unref(states)\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn! - 1))\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow! - 1))\n        const scrollBarWidth = getScrollBarWidth(ns.namespace.value)\n\n        const _cache = unref(cache)\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache)\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache)\n\n        scrollTo({\n          scrollLeft: getColumnOffset(\n            props,\n            columnIdx,\n            alignment,\n            _states.scrollLeft,\n            _cache,\n            estimatedWidth > props.width! ? scrollBarWidth : 0\n          ),\n          scrollTop: getRowOffset(\n            props,\n            rowIndex,\n            alignment,\n            _states.scrollTop,\n            _cache,\n            estimatedHeight > props.height! ? scrollBarWidth : 0\n          ),\n        })\n      }\n\n      const getItemStyle = (\n        rowIndex: number,\n        columnIndex: number\n      ): CSSProperties => {\n        const { columnWidth, direction, rowHeight } = props\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && columnWidth,\n          clearCache && rowHeight,\n          clearCache && direction\n        )\n        // since there was no need to introduce an nested array into cache object\n        // we use row,column to construct the key for indexing the map.\n        const key = `${rowIndex},${columnIndex}`\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key]\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache))\n          const _cache = unref(cache)\n\n          const rtl = isRTL(direction)\n          const [height, top] = getRowPosition(props, rowIndex, _cache)\n          const [width] = getColumnPosition(props, columnIndex, _cache)\n\n          itemStyleCache[key] = {\n            position: 'absolute',\n            left: rtl ? undefined : `${left}px`,\n            right: rtl ? `${left}px` : undefined,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`,\n          }\n\n          return itemStyleCache[key]\n        }\n      }\n\n      // TODO: debounce setting is scrolling.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      // life cycles\n      onMounted(() => {\n        // for SSR\n        if (!isClient) return\n        const { initScrollLeft, initScrollTop } = props\n        const windowElement = unref(windowRef)\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop\n          }\n        }\n        emitEvents()\n      })\n\n      const onUpdated = () => {\n        const { direction } = props\n        const { scrollLeft, scrollTop, updateRequested } = unref(states)\n\n        const windowElement = unref(windowRef)\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft\n                break\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft\n                break\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement\n                windowElement.scrollLeft =\n                  scrollWidth - clientWidth - scrollLeft\n                break\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft)\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop)\n        }\n      }\n\n      const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } =\n        instance.proxy as any\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter,\n      })\n\n      // rendering part\n\n      const renderScrollbars = () => {\n        const {\n          scrollbarAlwaysOn,\n          scrollbarStartGap,\n          scrollbarEndGap,\n          totalColumn,\n          totalRow,\n        } = props\n\n        const width = unref(parsedWidth)\n        const height = unref(parsedHeight)\n        const estimatedWidth = unref(estimatedTotalWidth)\n        const estimatedHeight = unref(estimatedTotalHeight)\n        const { scrollLeft, scrollTop } = unref(states)\n        const horizontalScrollbar = h(Scrollbar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e('horizontal'),\n          clientSize: width,\n          layout: 'horizontal',\n          onScroll: onHorizontalScroll,\n          ratio: (width * 100) / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true,\n        })\n\n        const verticalScrollbar = h(Scrollbar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e('vertical'),\n          clientSize: height,\n          layout: 'vertical',\n          onScroll: onVerticalScroll,\n          ratio: (height * 100) / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n\n          total: totalColumn,\n          visible: true,\n        })\n\n        return {\n          horizontalScrollbar,\n          verticalScrollbar,\n        }\n      }\n\n      const renderItems = () => {\n        const [columnStart, columnEnd] = unref(columnsToRender)\n        const [rowStart, rowEnd] = unref(rowsToRender)\n        const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props\n        const children: VNodeChild[] = []\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push(\n                slots.default?.({\n                  columnIndex: column,\n                  data,\n                  key: itemKey({ columnIndex: column, data, rowIndex: row }),\n                  isScrolling: useIsScrolling\n                    ? unref(states).isScrolling\n                    : undefined,\n                  style: getItemStyle(row, column),\n                  rowIndex: row,\n                })\n              )\n            }\n          }\n        }\n        return children\n      }\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement) as VNode\n        const children = renderItems()\n        return [\n          h(\n            Inner,\n            {\n              style: unref(innerStyle),\n              ref: innerRef,\n            },\n            !isString(Inner)\n              ? {\n                  default: () => children,\n                }\n              : children\n          ),\n        ]\n      }\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(\n          props.containerElement\n        ) as VNode\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars()\n        const Inner = renderInner()\n\n        return h(\n          'div',\n          {\n            key: 0,\n            class: ns.e('wrapper'),\n          },\n          [\n            h(\n              Container,\n              {\n                class: props.className,\n                style: unref(windowStyle),\n                onScroll,\n                onWheel,\n                ref: windowRef,\n              },\n              !isString(Container) ? { default: () => Inner } : Inner\n            ),\n            horizontalScrollbar,\n            verticalScrollbar,\n          ]\n        )\n      }\n\n      return renderWindow\n    },\n  })\n}\n\nexport default createGrid\n\ntype Dir = typeof FORWARD | typeof BACKWARD\n\nexport type GridInstance = InstanceType<ReturnType<typeof createGrid>> &\n  UnwrapRef<{\n    windowRef: Ref<HTMLElement>\n    innerRef: Ref<HTMLElement>\n    getItemStyleCache: ReturnType<typeof useCache>\n    scrollTo: (scrollOptions: GridScrollOptions) => void\n    scrollToItem: (\n      rowIndex: number,\n      columnIndex: number,\n      alignment: Alignment\n    ) => void\n    states: Ref<{\n      isScrolling: boolean\n      scrollLeft: number\n      scrollTop: number\n      updateRequested: boolean\n      xAxisScrollDir: Dir\n      yAxisScrollDir: Dir\n    }>\n  }>\n"]},"metadata":{},"sourceType":"module"}