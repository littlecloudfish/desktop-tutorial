var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { onMounted, readonly, ref, watch } from 'vue';
import { createDispatcher, findPlayer, usePlayerContext as useVimeContext, isWritableProp, } from '@vime/core';
/**
 * Finds and returns the closest ancestor player element to the given `el`.
 *
 * @param el A HTMLElement that is within the player's subtree.
 */
export const usePlayer = (el) => {
    const player = ref(null);
    const find = () => __awaiter(void 0, void 0, void 0, function* () {
        var _c;
        player.value = el.value ? (_c = (yield findPlayer(el.value))) !== null && _c !== void 0 ? _c : null : null;
    });
    onMounted(find);
    watch(el, find);
    return readonly(player);
};
/**
 * Binds the given `prop` to the closest ancestor player of the given `ref`. When the property
 * changes on the player, this hook will trigger a re-render with the new value.
 *
 * @param el The HTMLElement to start searching from.
 * @param prop The property to bind to.
 * @param defaultValue The initial value of the property until the the player context is bound.
 */
export const usePlayerContext = (el, prop, defaultValue) => {
    const noop = () => { };
    const binding = ref(defaultValue);
    const dispatch = ref(noop);
    let prevValue = defaultValue;
    watch(el, () => {
        dispatch.value = el.value ? createDispatcher(el.value) : noop;
    });
    watch(binding, () => {
        if (binding.value !== prevValue)
            dispatch.value(prop, binding.value);
    });
    watch(el, (_a, _b, onInvalidate) => __awaiter(void 0, void 0, void 0, function* () {
        if (!el.value)
            return;
        const off = yield useVimeContext(el.value, [prop], (_, newValue) => {
            binding.value = newValue;
            prevValue = newValue;
        });
        onInvalidate(off);
    }));
    return (isWritableProp(prop) ? binding : readonly(binding));
};
//# sourceMappingURL=composition.js.map